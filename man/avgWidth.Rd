% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prediction_intervals.R
\name{avgWidth}
\alias{avgWidth}
\title{Calculate interval forecast width}
\usage{
avgWidth(
  object,
  level = 95,
  includemedian = FALSE,
  window = NULL,
  na.rm = FALSE
)
}
\arguments{
\item{object}{An object of class \code{bb_cvforecast} or
\code{cb_cvforecast}.}

\item{level}{Target confidence level for prediction intervals.}

\item{includemedian}{If \code{TRUE}, the median interval width will also be
returned.}

\item{window}{If not \code{NULL}, the rolling mean (and rolling median if
applicable) matrix for interval width will also be returned.}

\item{na.rm}{A logical indicating whether \code{NA} values should be stripped
before the rolling mean and rolling median computation proceeds.}
}
\value{
A list of class \code{width} with the following components:
\item{width}{Forecast interval width as a multivariate time series, where the
\eqn{h}th column holds the interval width for the forecast horizon \eqn{h}.
The time index corresponds to the period for which the forecast is
produced.} \item{mean}{Mean interval width across the validation set.}
\item{rollmean}{If \code{window} is not \code{NULL}, a matrix of the rolling
means of interval width will be returned.} \item{median}{Median interval
width across the validation set.} \item{rollmedian}{If \code{window} is not
\code{NULL}, a matrix of the rolling medians of interval width will be
returned.}
}
\description{
This is a wrapper for the function \code{conformalForecast::width}.
Calculates the mean width of prediction intervals on the validation set. If
\code{window} is not \code{NULL}, a matrix of the rolling means of interval
width is also returned. If \code{includemedian} is \code{TRUE}, the
information of the median interval width will be returned.
}
\examples{
library(dplyr)
library(tibble)
library(tidyr)
library(tsibble)

# Simulate data
n = 1055
set.seed(123)
sim_data <- tibble(x_lag_000 = runif(n)) |>
  mutate(
    # Add x_lags
    x_lag = lag_matrix(x_lag_000, 5)) |>
  unpack(x_lag, names_sep = "_") |>
  mutate(
    # Response variable
    y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),
    # Add an index to the data set
    inddd = seq(1, n)) |>
  drop_na() |>
  select(inddd, y, starts_with("x_lag")) |>
  # Make the data set a `tsibble`
  as_tsibble(index = inddd)

# Training set
sim_train <- sim_data[1:1000, ]
# Test set
sim_test <- sim_data[1001:1050, ]

# Index variables
index.vars <- colnames(sim_data)[3:8]

# Model fitting
pprModel <- model_ppr(data = sim_train,
                      yvar = "y",
                      index.vars = index.vars)
                      
# Conformal bootstrap prediction intervals (2-steps-ahead interval forecasts)
set.seed(12345)
pprModel_cb <- cb_cvforecast(object = pprModel,
                             data = sim_data,
                             yvar = "y",
                             predictor.vars = index.vars,
                             h = 2,
                             ncal = 30,
                             num.futures = 100,
                             window = 1000)
                                 
# Mean width of generated 95\% conformal bootstrap prediction intervals
width_data <- avgWidth(object = pprModel_cb)
width_data$mean
                                 
}
