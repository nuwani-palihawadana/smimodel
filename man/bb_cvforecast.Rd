% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prediction_intervals.R
\name{bb_cvforecast}
\alias{bb_cvforecast}
\title{Single season block bootstrap prediction intervals through time series
cross-validation forecasting}
\usage{
bb_cvforecast(
  object,
  data,
  yvar,
  neighbour = 0,
  predictor.vars,
  h = 1,
  season.period = 1,
  m = 1,
  num.futures = 1000,
  level = c(80, 95),
  forward = TRUE,
  initial = 1,
  window = NULL,
  roll.length = 1,
  exclude.trunc = NULL,
  recursive = FALSE,
  recursive_colNames = NULL,
  na.rm = TRUE,
  ...
)
}
\arguments{
\item{object}{Fitted model object of class \code{smimodel}, \code{backward},
\code{gaimFit} or \code{pprFit}.}

\item{data}{Data set. Must be a data set of class \code{tsibble}.(Make sure
there are no additional date or time related variables except for the
\code{index} of the \code{tsibble}). If multiple models are fitted, the
grouping variable should be the \code{key} of the \code{tsibble}. If a
\code{key} is not specified, a dummy key with only one level will be
created.}

\item{yvar}{Name of the response variable as a character string.}

\item{neighbour}{If multiple models are fitted: Number of neighbours of each
key (i.e. grouping variable) to be considered in model fitting to handle
smoothing over the key. Should be an \code{integer}. If \code{neighbour =
  x}, \code{x} number of keys before the key of interest and \code{x} number
of keys after the key of interest are grouped together for model fitting.
The default is \code{neighbour = 0} (i.e. no neighbours are considered for
model fitting).}

\item{predictor.vars}{A character vector of names of the predictor variables.}

\item{h}{Forecast horizon.}

\item{season.period}{Length of the seasonal period.}

\item{m}{Multiplier. (Block size = \code{NULLseason.period * m})}

\item{num.futures}{Number of possible future sample paths to be generated.}

\item{level}{Confidence level for prediction intervals.}

\item{forward}{If \code{TRUE}, the final forecast origin for forecasting is
\eqn{y_T}. Otherwise, the final forecast origin is \eqn{y_{T-1}}.}

\item{initial}{Initial period of the time series where no cross-validation
forecasting is performed.}

\item{window}{Length of the rolling window. If \code{NULL}, a rolling window
will not be used.}

\item{roll.length}{Number of observations by which each rolling/expanding
window should be rolled forward.}

\item{exclude.trunc}{The names of the predictor variables that should not be
truncated for stable predictions as a character string. (Since the
nonlinear functions are estimated using splines, extrapolation is not
desirable. Hence, if any predictor variable is treated non-linearly in the
estimated model, will be truncated to be in the in-sample range before
obtaining predictions. If any variables are listed here will be excluded
from such truncation.)}

\item{recursive}{Whether to obtain recursive forecasts or not (default -
\code{FALSE}).}

\item{recursive_colNames}{If \code{recursive = TRUE}, a character vector
giving the names of the columns in test data to be filled with forecasts.
Recursive/autoregressive forecasting is required when the lags of the
response variable itself are used as predictor variables into the model.
Make sure such lagged variables are positioned together in increasing lag
order (i.e. \code{lag_1, lag_2, ..., lag_m}, \code{lag_m =} maximum lag
used) in \code{data}, with no break in the lagged variable sequence even if
some of the intermediate lags are not used as predictors.}

\item{na.rm}{logical; if \code{TRUE} (default), any \code{NA} and
\code{NaN}'s are removed from the sample before the quantiles are computed.}

\item{...}{Other arguments not currently used.}
}
\value{
An object of class \code{bb_cvforecast}, which is a list that
contains following elements: \item{x}{The original time series.}
\item{method}{A character string "bb_cvforecast".} \item{fit_times}{The
number of times the model is fitted in cross-validation.}
\item{mean}{Point forecasts as a multivariate time series, where the
\eqn{h^{th}} column holds the point forecasts for forecast horizon \eqn{h}.
The time index corresponds to the period for which the forecast is produced.}
\item{res}{The matrix of in-sample residuals produced in cross-validation.
The number of rows corresponds to \code{fit_times}, and the row names
corresponds the time index of the forecast origin of the corresponding
cross-validation iteration.} \item{level}{The confidence values
associated with the prediction intervals.} \item{lower}{A list containing
lower bounds for prediction intervals for each level. Each element within
the list will be a multivariate time series with the same dimensional
characteristics as \code{mean}.} \item{upper}{A list containing upper bounds
for prediction intervals for each level. Each element within the list will
be a multivariate time series with the same dimensional characteristics as
\code{mean}.}
}
\description{
Compute prediction intervals by applying the single season block bootstrap
method to subsets of time series data using a rolling forecast origin.
}
\examples{
\dontrun{
library(dplyr)
library(ROI)
library(tibble)
library(tidyr)
library(tsibble)

# Simulate data
n = 1105
set.seed(123)
sim_data <- tibble(x_lag_000 = runif(n)) |>
  mutate(
    # Add x_lags
    x_lag = lag_matrix(x_lag_000, 5)) |>
  unpack(x_lag, names_sep = "_") |>
  mutate(
    # Response variable
    y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 +
    (0.35*x_lag_002 + 0.7*x_lag_005)^2 + rnorm(n, sd = 0.1),
    # Add an index to the data set
    inddd = seq(1, n)) |>
  drop_na() |>
  select(inddd, y, starts_with("x_lag")) |>
  # Make the data set a `tsibble`
  as_tsibble(index = inddd)

# Index variables
index.vars <- colnames(sim_data)[3:8]

# Training set
sim_train <- sim_data[1:1000, ]
# Test set
sim_test <- sim_data[1001:1100, ]

# Model fitting
smimodel_ppr <- model_smimodel(data = sim_train,
                               yvar = "y",
                               index.vars = index.vars,
                               initialise = "ppr")

# Block bootstrap prediction intervals (3-steps-ahead interval forecasts)
set.seed(12345)
smimodel_ppr_bb <- bb_cvforecast(object = smimodel_ppr,
                                 data = sim_data,
                                 yvar = "y",
                                 predictor.vars = index.vars,
                                 h = 3,
                                 num.futures = 50,
                                 window = 1000)
}

}
\seealso{
\code{\link{cb_cvforecast}}
}
