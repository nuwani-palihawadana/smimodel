% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model_backward.R
\name{model_backward}
\alias{model_backward}
\title{Nonparametric Additive Model with Backward Elimination}
\usage{
model_backward(
  data,
  val.data,
  yvar,
  neighbour = 0,
  family = gaussian(),
  s.vars = NULL,
  s.basedim = NULL,
  linear.vars = NULL,
  refit = TRUE,
  tol = 0.001,
  parallel = FALSE,
  workers = NULL,
  exclude.trunc = NULL,
  recursive = FALSE,
  recursive_colRange = NULL
)
}
\arguments{
\item{data}{Training data set on which models will be trained. Must be a data
set of class \code{tsibble}.(Make sure there are no additional date or time
related variables except for the \code{index} of the \code{tsibble}). If
multiple models are fitted, the grouping variable should be the \code{key}
of the \code{tsibble}. If a \code{key} is not specified, a dummy key with
only one level will be created.}

\item{val.data}{Validation data set. (The data set on which the model
selection will be performed.) Must be a data set of class \code{tsibble}.}

\item{yvar}{Name of the response variable as a character string.}

\item{neighbour}{If multiple models are fitted: Number of neighbours of each
key (i.e. grouping variable) to be considered in model fitting to handle
smoothing over the key. Should be an \code{integer}. If \code{neighbour =
  x}, \code{x} number of keys before the key of interest and \code{x} number
of keys after the key of interest are grouped together for model fitting.
The default is \code{neighbour = 0} (i.e. no neighbours are considered for
model fitting).}

\item{family}{A description of the error distribution and link function to be
used in the model (see \code{\link{glm}} and \code{\link{family}}).}

\item{s.vars}{A \code{character} vector of names of the predictor variables
for which splines should be fitted (i.e. non-linear predictors).}

\item{s.basedim}{Dimension of the bases used to represent the smooth terms
corresponding to \code{s.vars}. (For more information refer
\code{mgcv::s()}.)}

\item{linear.vars}{A \code{character} vector of names of the predictor
variables that should be included linearly into the model (i.e. linear
predictors).}

\item{refit}{Whether to refit the model combining training and validation
sets after model selection. If \code{FALSE}, the final model will be
estimated only on the training set.}

\item{tol}{Tolerance for the ratio of relative change in validation set MSE,
used in model selection.}

\item{parallel}{Whether to use parallel computing in model selection or not.}

\item{workers}{If \code{parallel = TRUE}, number of workers to use.}

\item{exclude.trunc}{The names of the predictor variables that should not be
truncated for stable predictions as a character string. (Since the
nonlinear functions are estimated using splines, extrapolation is not
desirable. Hence, if any predictor variable in \code{val.data} that is treated
non-linearly in the estimated model, will be truncated to be in the
in-sample range before obtaining predictions. If any variables are listed
here will be excluded from such truncation.)}

\item{recursive}{Whether to obtain recursive forecasts or not (default -
\code{FALSE}).}

\item{recursive_colRange}{If \code{recursive = TRUE}, the range of column
numbers in \code{val.data} to be filled with forecasts.
Recursive/autoregressive forecasting is required when the lags of the
response variable itself are used as predictor variables into the model.
Make sure such lagged variables are positioned together in increasing lag
order (i.e. \code{lag_1, lag_2, ..., lag_m}, \code{lag_m =} maximum lag
used) in \code{val.data}, with no break in the lagged variable sequence
even if some of the intermediate lags are not used as predictors.}
}
\value{
An object of class \code{backward}. This is a \code{tibble} with two
columns: \item{key}{The level of the grouping variable (i.e. key of the
training data set).} \item{fit}{Information of the fitted model
corresponding to the \code{key}.} Each row of the column \code{fit} is an
object of class \code{gam}. For details refer \code{mgcv::gamObject}.
}
\description{
Fits a nonparametric additive model, with simultaneous variable selection
through a backward elimination procedure as proposed by Fan and Hyndman
(2012).
}
\details{
This function fits a nonparametric additive model formulated through
Backward Elimination, as proposed by Fan and Hyndman (2012). The process
starts with all predictors included in an additive model, and predictors
are progressively omitted until the best model is obtained based on the
validation set. Once the best model is obtained, the final model is
re-fitted for the data set combining training and validation sets. For more
details see reference.
}
\examples{
library(dplyr)
library(tibble)
library(tidyr)
library(tsibble)

# Simulate data
n = 1205
set.seed(123)
sim_data <- tibble(x_lag_000 = runif(n)) |>
  mutate(
    # Add x_lags
    x_lag = lag_matrix(x_lag_000, 5)) |>
  unpack(x_lag, names_sep = "_") |>
  mutate(
    # Response variable
    y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),
    # Add an index to the data set
    inddd = seq(1, n)) |>
  drop_na() |>
  select(inddd, y, starts_with("x_lag")) |>
  # Make the data set a `tsibble`
  as_tsibble(index = inddd)

# Training set
sim_train <- sim_data[1:1000, ]
# Validation set
sim_val <- sim_data[1001:1200, ]

# Predictors taken as non-linear variables
s.vars <- colnames(sim_data)[3:8]

# Model fitting
backwardModel <- model_backward(data = sim_train,
                                val.data = sim_val,
                                yvar = "y",
                                s.vars = s.vars)
# Fitted model
backwardModel$fit[[1]]

}
\references{
Fan, S. & Hyndman, R.J. (2012). Short-Term Load Forecasting Based
on a Semi-Parametric Additive Model. \emph{IEEE Transactions on Power Systems},
27(1), 134-141.\doi{10.1109/TPWRS.2011.2162082}.
}
\seealso{
\code{\link{model_smimodel}}, \code{\link{model_gaim}},
\code{\link{model_ppr}}, \code{\link{model_gam}}, \code{\link{model_lm}}
}
