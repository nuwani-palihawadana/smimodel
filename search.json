[{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://nuwani-palihawadana.github.io/smimodel/articles/smimodel.html","id":"what-is-smimodel","dir":"Articles","previous_headings":"","what":"What is smimodel?","title":"Introduction to smimodel","text":"smimodel package provides functions estimate Sparse Multiple Index (SMI) Models nonparametric forecasting prediction. support time series forecasting, package functions mainly build upon tidy temporal data tsibble format. However, SMI model formulation general exclusively depend temporal features. Hence, model can used widely—even non-temporal cross-sectional data. (case, numeric index (instead date time related variable) can used constructing tsibble.) SMI Modelling algorithm (.e. estimation algorithm SMI model) implement , simultaneously performs automatic predictor selection (“sparse”) predictor grouping, especially useful obtaining parsimonious model high-dimensional contexts.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/articles/smimodel.html","id":"how-to-use-smimodel","dir":"Articles","previous_headings":"","what":"How to use smimodel?","title":"Introduction to smimodel","text":"present simple example illustrate smimodel functionalities. use randomly simualted data, treat time series data purpose illustration. (Note: Since SMI model estimation algorithm works limited amount prior information, handles automatic predictor selection predictor grouping, computational time model estimation increases number predictors number indices increase. Therefore, use small simulated data set example reduce computational cost.)","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/articles/smimodel.html","id":"data-simulation","dir":"Articles","previous_headings":"How to use smimodel?","what":"Data simulation","title":"Introduction to smimodel","text":"Suppose interested forecasting response variable yy, additive function two nonlinear components involving five predictor variables x_000,x_001,x_002,x_003x\\_000, x\\_001, x\\_002, x\\_003 x_005x\\_005 plus normally distributed white noise component. , variables x_001,x_002,x_003x\\_001, x\\_002, x\\_003 x_005x\\_005 correspond first, second, third fifth lags x_000x\\_000 respectively. Note create additional numeric variable inddd serve index data set, convert data set object class tsibble. Next, split data training test sets models can estimated using training data set, fitted models can evaluated predictions obtained test set, used model estimation.","code":"## Load required packages  library(smimodel) library(dplyr) library(ROI) library(tibble) library(tidyr) library(tsibble) ## Simulate data  # Length of the time series n = 1405   # Set a seed for reproduciblity set.seed(123)  # Generate data sim_data <- tibble(x_000 = runif(n)) |>    mutate(     # Add x_lags     x = lag_matrix(x_000, 5)) |>    unpack(x, names_sep = \"_\") |>    mutate(     # Response variable     y = (0.9*x_000 + 0.6*x_001 + 0.45*x_003)^3 +        (0.35*x_002 + 0.7*x_005)^2 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>    drop_na() |>    select(inddd, y, starts_with(\"x_\")) |>    # Make the data set a `tsibble`   as_tsibble(index = inddd) ## Data Split  # Training set sim_train <- sim_data[1:1200, ]  # Test set sim_test <- sim_data[1201:1400, ]  # Here, we sequentially split the data as we assume time series data."},{"path":"https://nuwani-palihawadana.github.io/smimodel/articles/smimodel.html","id":"smi-model-estimation","dir":"Articles","previous_headings":"How to use smimodel?","what":"SMI model estimation","title":"Introduction to smimodel","text":"first train SMI models training set using three different initialisation options “ppr”, “additive” “linear” comparison purposes. Please refer package documentation/working paper information regarding available initialisation options. (Note: choice initialisation largely depends data application. Thus, users encouraged follow trial--error procedure determine suitable initial model given application.) , assume prior knowledge construction response variable yy. Hence, input x_000x\\_000 first five lags predictor variables estimation algorithm, predictors entering indices.","code":"## Index variables index.vars <- colnames(sim_data)[3:8]"},{"path":"https://nuwani-palihawadana.github.io/smimodel/articles/smimodel.html","id":"smi-model-with-ppr-initialisation","dir":"Articles","previous_headings":"How to use smimodel? > SMI model estimation","what":"SMI model with “ppr” initialisation:","title":"Introduction to smimodel","text":"","code":"## SMI model with \"PPR\" initialisation smimodel_ppr <- model_smimodel(data = sim_train,                                yvar = \"y\",                                index.vars = index.vars,                                initialise = \"ppr\") #> [1] \"model 1\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" # Fitted optimal SMI model smimodel_ppr$fit[[1]]$best #> SMI Model Fit: #> Index coefficients: #> 6 x 2 sparse Matrix of class \"dgCMatrix\" #>          index1   index2 #> x_000 0.4636151 .        #> x_001 0.3055133 .        #> x_002 .         0.345222 #> x_003 0.2308716 .        #> x_004 .         .        #> x_005 .         0.654778 #>  #> Response variable: #> [1] \"y\" #>  #> Index variables: #> [1] \"x_000\" \"x_001\" \"x_002\" \"x_003\" \"x_004\" \"x_005\" #>  #> Spline variables (non-index): #> NULL #>  #> Linear variables: #> NULL #>  #> GAM Fit: #> Family: gaussian  #> Link function: identity  #>  #> Formula: #> y ~ s(index1, bs = \"cr\") + s(index2, bs = \"cr\") #>  #> Estimated degrees of freedom: #> 8.5 6.1  total = 15.6  #>  #> REML score: -1028.854 # Estimated index structure smimodel_ppr$fit[[1]]$best$alpha #> 6 x 2 sparse Matrix of class \"dgCMatrix\" #>          index1   index2 #> x_000 0.4636151 .        #> x_001 0.3055133 .        #> x_002 .         0.345222 #> x_003 0.2308716 .        #> x_004 .         .        #> x_005 .         0.654778"},{"path":"https://nuwani-palihawadana.github.io/smimodel/articles/smimodel.html","id":"smi-model-with-additive-initialisation","dir":"Articles","previous_headings":"How to use smimodel? > SMI model estimation","what":"SMI model with “additive” initialisation:","title":"Introduction to smimodel","text":"","code":"## SMI model with \"Additive\" initialisation smimodel_additive <- model_smimodel(data = sim_train,                                     yvar = \"y\",                                     index.vars = index.vars,                                     initialise = \"additive\") #> [1] \"model 1\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" # Fitted optimal SMI model smimodel_additive$fit[[1]]$best #> SMI Model Fit: #> Index coefficients: #> 6 x 2 sparse Matrix of class \"dgCMatrix\" #>          index1    index2 #> x_000 0.4634955 .         #> x_001 0.3054954 .         #> x_002 .         0.3451773 #> x_003 0.2310091 .         #> x_004 .         .         #> x_005 .         0.6548227 #>  #> Response variable: #> [1] \"y\" #>  #> Index variables: #> [1] \"x_000\" \"x_001\" \"x_002\" \"x_003\" \"x_004\" \"x_005\" #>  #> Spline variables (non-index): #> NULL #>  #> Linear variables: #> NULL #>  #> GAM Fit: #> Family: gaussian  #> Link function: identity  #>  #> Formula: #> y ~ s(index1, bs = \"cr\") + s(index2, bs = \"cr\") #>  #> Estimated degrees of freedom: #> 8.50 6.09  total = 15.59  #>  #> REML score: -1028.856 # Estimated index structure smimodel_additive$fit[[1]]$best$alpha #> 6 x 2 sparse Matrix of class \"dgCMatrix\" #>          index1    index2 #> x_000 0.4634955 .         #> x_001 0.3054954 .         #> x_002 .         0.3451773 #> x_003 0.2310091 .         #> x_004 .         .         #> x_005 .         0.6548227"},{"path":"https://nuwani-palihawadana.github.io/smimodel/articles/smimodel.html","id":"smi-model-with-linear-initialisation","dir":"Articles","previous_headings":"How to use smimodel? > SMI model estimation","what":"SMI model with “linear” initialisation:","title":"Introduction to smimodel","text":"case, SMI models fitted “ppr” “additive” initialisation options correctly identified index structure response yy estimating two linear combinations (.e. indices), dropping irrelevant predictor x_004x\\_004. correctly identifying x_004x\\_004 irrelevant predictor variable, SMI model estimated “linear” initialisation however, correctly identified index structure model—estimated single index instead two indices. Thus, mentioned earlier, final estimated model can change depending initialisation option chosen. Hence, users encouraged experiment different available initialisation options choosing best fit data/application interest. (real-world problem (true model unknown), useful fit SMI models different initialisation options, see option gives best forecasting/prediction accuracy.)","code":"## SMI model with \"Linear\" initialisation smimodel_linear <- model_smimodel(data = sim_train,                                   yvar = \"y\",                                   index.vars = index.vars,                                   initialise = \"linear\") #> [1] \"model 1\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" # Fitted optimal SMI model smimodel_linear$fit[[1]]$best #> SMI Model Fit: #> Index coefficients: #> 6 x 1 sparse Matrix of class \"dgCMatrix\" #>           index1 #> x_000 0.40811741 #> x_001 0.26853838 #> x_002 0.04185720 #> x_003 0.20411136 #> x_004 .          #> x_005 0.07737565 #>  #> Response variable: #> [1] \"y\" #>  #> Index variables: #> [1] \"x_000\" \"x_001\" \"x_002\" \"x_003\" \"x_004\" \"x_005\" #>  #> Spline variables (non-index): #> NULL #>  #> Linear variables: #> NULL #>  #> GAM Fit: #> Family: gaussian  #> Link function: identity  #>  #> Formula: #> y ~ s(index1, bs = \"cr\") #>  #> Estimated degrees of freedom: #> 7.8  total = 8.8  #>  #> REML score: -445.1356 # Estimated index structure smimodel_linear$fit[[1]]$best$alpha #> 6 x 1 sparse Matrix of class \"dgCMatrix\" #>           index1 #> x_000 0.40811741 #> x_001 0.26853838 #> x_002 0.04185720 #> x_003 0.20411136 #> x_004 .          #> x_005 0.07737565"},{"path":"https://nuwani-palihawadana.github.io/smimodel/articles/smimodel.html","id":"visualisation-of-estimated-smooths","dir":"Articles","previous_headings":"How to use smimodel?","what":"Visualisation of estimated smooths","title":"Introduction to smimodel","text":"fit SMI model, partial effects estimated smooths corresponding estimated indices can plotted using autoplot method .","code":"## Plot estimated smooths of the SMI model with \"ppr\" initialisation autoplot(object = smimodel_ppr)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/articles/smimodel.html","id":"residuals-and-fitted-values","dir":"Articles","previous_headings":"How to use smimodel?","what":"Residuals and fitted values","title":"Introduction to smimodel","text":"can use augment method obtain residuals fitted values estimated SMI model.","code":"## Obtain residuals and fitted values augment(x = smimodel_ppr) #> # A tibble: 1,200 × 3 #>    Index   .resid .fitted #>    <int>    <dbl>   <dbl> #>  1     6  0.0566    0.757 #>  2     7 -0.0397    1.50  #>  3     8 -0.0552    3.78  #>  4     9  0.0499    1.78  #>  5    10  0.155     1.88  #>  6    11 -0.145     3.70  #>  7    12  0.200     2.16  #>  8    13 -0.00571   2.20  #>  9    14 -0.0585    2.78  #> 10    15  0.0690    0.588 #> # ℹ 1,190 more rows"},{"path":"https://nuwani-palihawadana.github.io/smimodel/articles/smimodel.html","id":"forecasts-on-a-test-set","dir":"Articles","previous_headings":"How to use smimodel?","what":"Forecasts on a test set","title":"Introduction to smimodel","text":"Based estimated SMI model, obtain forecasts/predictions test set , using predict method. obtain forecasts/predictions, can evaluate forecasting/predictive performance estimated SMI model calculating forecast/prediction error measurements desired.","code":"## Obtain forecasts on the test set preds = predict(object = smimodel_ppr, newdata = sim_test) preds$.predict #>          1          2          3          4          5          6          7          8  #> 3.45875259 1.52227838 0.52881104 2.24035158 1.12107147 1.37713685 3.45942510 1.29280288  #>          9         10         11         12         13         14         15         16  #> 1.30480760 0.76693416 0.94033375 1.69198167 1.19066341 1.31326856 1.62227903 2.32393332  #>         17         18         19         20         21         22         23         24  #> 0.83445703 1.04508990 1.18655331 4.77834376 0.61094061 1.14584964 0.79738240 1.40808298  #>         25         26         27         28         29         30         31         32  #> 2.33526200 0.17577515 0.55496943 0.36529819 0.86680931 0.58204728 0.07682039 0.12715469  #>         33         34         35         36         37         38         39         40  #> 0.59371085 2.34226095 0.88236602 0.31311292 0.47272680 0.98719807 1.08509641 1.63224918  #>         41         42         43         44         45         46         47         48  #> 1.08438592 0.94669238 0.69782251 0.29352743 1.42720367 1.80572138 1.56637665 1.60908623  #>         49         50         51         52         53         54         55         56  #> 0.46992486 0.52987039 1.75371557 0.35670514 0.52323854 2.84421134 1.52535348 1.21157098  #>         57         58         59         60         61         62         63         64  #> 1.57454092 0.35167609 0.81628181 1.16983691 0.14744439 0.76252668 3.59290968 0.41181444  #>         65         66         67         68         69         70         71         72  #> 2.45049844 1.07340894 0.95589469 2.55008954 0.60641501 3.72815494 1.90521972 2.62653129  #>         73         74         75         76         77         78         79         80  #> 2.97443784 1.17261901 1.32266114 0.58847194 1.53256266 2.14620254 1.74196253 2.66079827  #>         81         82         83         84         85         86         87         88  #> 0.79429653 2.20897818 1.95718405 1.04773411 1.37572254 2.27213107 1.86737728 0.84856583  #>         89         90         91         92         93         94         95         96  #> 2.17397767 1.42471476 0.92667153 2.26161088 2.21898501 3.09128273 2.79447124 0.60599090  #>         97         98         99        100        101        102        103        104  #> 1.10399804 1.38587451 1.84832772 2.95928627 1.75660705 0.83714657 0.44664008 1.24110982  #>        105        106        107        108        109        110        111        112  #> 0.44727137 0.43799614 0.43482032 1.11403760 0.90800010 0.98409355 0.77391461 0.92785753  #>        113        114        115        116        117        118        119        120  #> 1.44316813 0.53590956 0.70992483 0.71795358 1.41767391 1.35755259 2.13572836 2.08429360  #>        121        122        123        124        125        126        127        128  #> 2.88077416 0.93061594 2.19668318 0.26132355 1.22310358 1.28597904 0.54794253 1.30397046  #>        129        130        131        132        133        134        135        136  #> 1.46474006 1.18312452 0.66352232 1.22851353 2.41435557 2.60599716 2.59239098 0.97740761  #>        137        138        139        140        141        142        143        144  #> 1.39710803 1.03604458 0.73902008 1.11037088 2.98249685 1.16392033 1.56621624 2.29963520  #>        145        146        147        148        149        150        151        152  #> 1.45009245 1.01222387 0.19617259 0.24803096 0.17703054 0.24552278 0.11939235 0.06335250  #>        153        154        155        156        157        158        159        160  #> 0.78697563 0.77510661 0.44432578 2.11483463 0.36391308 1.84129095 1.72201999 0.56247570  #>        161        162        163        164        165        166        167        168  #> 0.86526871 0.15401982 0.86083789 0.36209679 0.16949950 0.38394360 0.08912956 0.44100934  #>        169        170        171        172        173        174        175        176  #> 0.88294634 1.29236413 2.58720558 1.48371732 3.04050479 1.20272911 1.04586676 2.14226125  #>        177        178        179        180        181        182        183        184  #> 0.44197929 2.79409719 0.52716239 1.55409562 1.42580960 0.36626185 2.72545139 0.29608435  #>        185        186        187        188        189        190        191        192  #> 0.87043136 2.92144635 1.94118373 1.64383166 1.23771152 0.96011483 2.37079432 2.37095016  #>        193        194        195        196        197        198        199        200  #> 1.44371807 0.58065932 0.37881098 0.50417286 0.34462475 0.18876236 0.20226401 0.26617350 ## Calculate test set MSE and MAE MSE_SMI_ppr = MSE(residuals = (preds$y - preds$.predict)) MSE_SMI_ppr #> [1] 0.01267397 MAE_SMI_ppr = MAE(residuals = (preds$y - preds$.predict)) MAE_SMI_ppr #> [1] 0.08956935"},{"path":"https://nuwani-palihawadana.github.io/smimodel/articles/smimodel.html","id":"tuning-for-penalty-parameters","dir":"Articles","previous_headings":"How to use smimodel?","what":"Tuning for penalty parameters","title":"Introduction to smimodel","text":"estimation SMI model involves solving optimaisation problem, sum squared errors model plus two penalty terms (L0 penalty L2 (ridge) penalty) minimised subject set constraints. Thus, two penalty parameters λ0\\lambda_{0} λ2\\lambda_{2} corresponding L0 L2 penalties respectively chosen estimating SMI model. previous example, SMI models fitted using default penalty parameter values provided function: λ0=1\\lambda_{0} = 1 λ2=1\\lambda_{2} = 1. fit SMI model simultaneous parameter tuning, can use function greedy_smimodel(), performs greedy search partially data-derived grid possible penalty parameter combinations (λ0\\lambda_{0}, λ2\\lambda_{2}), fits SMI model using best (lowest validation set MSE) penalty parameter combination. case, need provide validation set, separate training data set. Therefore, let’s split original training set example two parts obtain validation set. Next, can estimate SMI model simultaneous penalty parameter tuning follows. , use initialisation option “ppr” just demonstrate functionality. selected penalty parameter combination (λ0,λ2)=(0.01356766,0.01000000)(\\lambda_{0}, \\lambda_{2}) = (0.01356766, 0.01000000).","code":"# New training set sim_train_new <- sim_data[1:1000, ]  # Validation set sim_val_new <- sim_data[1001:1200, ] ## Estimating SMI model with penalty parameter tuning smimodel_ppr_tune <- greedy_smimodel(data = sim_train_new,                                       val.data = sim_val_new,                                      yvar = \"y\",                                      index.vars = index.vars,                                      initialise = \"ppr\") #> [1] \"model 1\" #> [1] \"model 1\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Potential starting points completed.\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"Initial search around potential starting point 1 completed.\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Initial search around potential starting point 2 completed.\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Initial search around potential starting point 3 completed.\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"Maximum iterations reached!\" #> [1] \"Final model fitted!\" #> [1] \"Initial search around potential starting point 4 completed.\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"Initial search around potential starting point 5 completed.\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Initial search around potential starting point 6 completed.\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Initial search around potential starting point 7 completed.\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"Initial search around potential starting point 8 completed.\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Initial search around potential starting point 9 completed.\" #> [1] \"Starting point for the greedy search selected.\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"An iteration of greedy search - step 1 is completed.\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"Tolerance for loss reached!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Loss increased for 3 consecutive iterations!\" #> [1] \"Final model fitted!\" #> [1] \"An iteration of greedy search - step 1 is completed.\" #> [1] \"Maximum iterations reached!\" #> [1] \"Maximum iterations reached!\" #> [1] \"Final model fitted!\" #> [1] \"Final SMI model is fitted.\" # Fitted optimal SMI model smimodel_ppr_tune$fit[[1]]$best #> SMI Model Fit: #> Index coefficients: #> 6 x 3 sparse Matrix of class \"dgCMatrix\" #>          index1 index2 index3 #> x_000 0.4632129      .      . #> x_001 0.3058459      .      . #> x_002 .              .      1 #> x_003 0.2309412      .      . #> x_004 .              .      . #> x_005 .              1      . #>  #> Response variable: #> [1] \"y\" #>  #> Index variables: #> [1] \"x_000\" \"x_001\" \"x_002\" \"x_003\" \"x_004\" \"x_005\" #>  #> Spline variables (non-index): #> NULL #>  #> Linear variables: #> NULL #>  #> GAM Fit: #> Family: gaussian  #> Link function: identity  #>  #> Formula: #> y ~ s(index1, bs = \"cr\") + s(index2, bs = \"cr\") + s(index3, bs = \"cr\") #>  #> Estimated degrees of freedom: #> 8.43 4.30 2.99  total = 16.72  #>  #> REML score: -945.3404 ## Selected penalty parameter combination smimodel_ppr_tune$fit[[1]]$best_lambdas #> [1] 0.01356766 0.01000000"},{"path":"https://nuwani-palihawadana.github.io/smimodel/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nuwani Palihawadana. Author, maintainer, copyright holder. Xiaoqian Wang. Contributor.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Palihawadana N (2026). smimodel: Sparse Multiple Index Models Nonparametric Forecasting. R package version 0.0.1, https://github.com/nuwani-palihawadana/smimodel.","code":"@Manual{,   title = {smimodel: Sparse Multiple Index Models for Nonparametric Forecasting},   author = {Nuwani Palihawadana},   year = {2026},   note = {R package version 0.0.1},   url = {https://github.com/nuwani-palihawadana/smimodel}, }"},{"path":"https://nuwani-palihawadana.github.io/smimodel/index.html","id":"smimodel-","dir":"","previous_headings":"","what":"Sparse Multiple Index Models for Nonparametric Forecasting","title":"Sparse Multiple Index Models for Nonparametric Forecasting","text":"R package smimodel provides functions estimate Sparse Multiple Index (SMI) Models nonparametric forecasting/prediction. SMI Modelling algorithm simultaneously performs optimal predictor selection (hence “sparse”) predictor grouping, enabling parsimonious forecasting/prediction models high-dimensional context. package also includes functions fit benchmark comparison methods namely nonparametric additive model backward elimination, group-wise additive index model projection pursuit regression. functions designed similar syntax output format convenient usage interchangeability.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/index.html","id":"additional-functionalities","dir":"","previous_headings":"","what":"Additional Functionalities:","title":"Sparse Multiple Index Models for Nonparametric Forecasting","text":"Furthermore, smimodel package provides functions generate prediction intervals estimate uncertainty point forecasts produced SMI model given benchmark models time series forecasting problems. classical Block Bootstrap method novel method named Conformal Bootstrap, natural integration block bootstrap classical split conformal prediction, implemented prediction interval generation methods general online updating procedure introduced Wang Hyndman (2024) (https://arxiv.org/pdf/2410.13115).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Sparse Multiple Index Models for Nonparametric Forecasting","text":"can install released version smimodel CRAN: can install development version smimodel GitHub:","code":"install.packages(\"smimodel\") # install.packages(\"pak\") pak::pak(\"nuwani-palihawadana/smimodel\")"},{"path":[]},{"path":"https://nuwani-palihawadana.github.io/smimodel/index.html","id":"gurobi-solver","dir":"","previous_headings":"Other Required Software","what":"Gurobi Solver","title":"Sparse Multiple Index Models for Nonparametric Forecasting","text":"estimation SMI model based iterative procedure developed using Mixed Integer Programming (MIP) solve L0 L2-regularised nonlinear least squares optimisation problem linear constraints. use commercial MIP solver Gurobi solve mixed integer programs, fastest powerful MIP solver currently available. Hence, users smimodel required active installation Gurobi local machines.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/index.html","id":"license","dir":"","previous_headings":"Other Required Software > Gurobi Solver","what":"License","title":"Sparse Multiple Index Models for Nonparametric Forecasting","text":"Since Gurobi commercial software, users need obtain license Gurobi can install/use . Gurobi provides free license academics affiliated recognised educational institutions. Hence, academic, can register free account verified institutional email, request free academic license. affiliated recognised educational institution, might need purchase license long term use. However, can obtain free 30-day trial requesting evaluation license.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/index.html","id":"installation-1","dir":"","previous_headings":"Other Required Software > Gurobi Solver","what":"Installation","title":"Sparse Multiple Index Models for Nonparametric Forecasting","text":"Fortunately, Gurobi provides comprehensive documentation regarding installation well usage, provides active support Gurobi Help Center. step--step instructions software installation license activation process, go link. Note procedure installing Gurobi depends operating system using local machine. platform-specific instructions can found .","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/index.html","id":"r-package-gurobi","dir":"","previous_headings":"Other Required Software","what":"R Package “gurobi”","title":"Sparse Multiple Index Models for Nonparametric Forecasting","text":"Gurobi solver installed local machine, next need install Gurobi R interface “gurobi” R package, use gurobi within R. package available CRAN, exclusively distributed Gurobi software suite. instructions install gurobi R package provided .","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Sparse Multiple Index Models for Nonparametric Forecasting","text":"basic example, shows estimate SMI model, obtain predictions test set:","code":"library(smimodel) library(dplyr) library(ROI) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1205 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>    mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>    unpack(x_lag, names_sep = \"_\") |>    mutate(     # Response variable     y1 = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>    drop_na() |>    select(inddd, y1, starts_with(\"x_lag\")) |>    # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1200, ]  # Index variables index.vars <- colnames(sim_data)[3:8] # Estimate SMI model (with \"PPR\" initialisation) smimodel_ppr <- model_smimodel(data = sim_train,                                yvar = \"y1\",                                index.vars = index.vars,                                initialise = \"ppr\")  # Fitted SMI model smimodel_ppr$fit[[1]]$best # Plot estimated smooths autoplot(object = smimodel_ppr) # Obtain residuals and fitted values augment(x = smimodel_ppr) #> # A tibble: 1,000 × 3 #>    Index  .resid .fitted #>    <int>   <dbl>   <dbl> #>  1     6  0.0859   0.495 #>  2     7  0.0766   0.737 #>  3     8  0.137    3.70  #>  4     9  0.0173   1.15  #>  5    10  0.118    0.942 #>  6    11 -0.201    3.65  #>  7    12 -0.0471   1.83  #>  8    13  0.0111   1.28  #>  9    14 -0.0464   2.46  #> 10    15  0.0243   0.261 #> # ℹ 990 more rows # Obtain predictions on the test set predict(object = smimodel_ppr, newdata = sim_test)$.predict"},{"path":"https://nuwani-palihawadana.github.io/smimodel/index.html","id":"license-1","dir":"","previous_headings":"","what":"License","title":"Sparse Multiple Index Models for Nonparametric Forecasting","text":"package free open-source software, licensed GPL-3.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/allpred_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructing index coefficient vectors with all predictors in each index — allpred_index","title":"Constructing index coefficient vectors with all predictors in each index — allpred_index","text":"Constructs vectors coefficients index including coefficient predictors entering indices. .e. coefficient provided particular predictor particular index, function replace missing coefficient zero.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/allpred_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructing index coefficient vectors with all predictors in each index — allpred_index","text":"","code":"allpred_index(num_pred, num_ind, ind_pos, alpha)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/allpred_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructing index coefficient vectors with all predictors in each index — allpred_index","text":"num_pred Number predictors. num_ind Number indices. ind_pos list length = num_ind indicates predictors belong index. alpha vector index coefficients.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/allpred_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructing index coefficient vectors with all predictors in each index — allpred_index","text":"list containing following components: alpha_init_new numeric vector index coefficients. index integer vector assigns group indices predictor. index_positions list length = num_ind indicates predictors belong index.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.backward.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment function for class backward — augment.backward","title":"Augment function for class backward — augment.backward","text":"Generates residuals fitted values fitted backward object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.backward.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment function for class backward — augment.backward","text":"","code":"# S3 method for class 'backward' augment(x, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.backward.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment function for class backward — augment.backward","text":"x backward object. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.backward.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment function for class backward — augment.backward","text":"tibble.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.backward.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Augment function for class backward — augment.backward","text":"","code":"library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(tibble) library(tidyr) library(tsibble) #>  #> Attaching package: ‘tsibble’ #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, union  # Simulate data n = 1205 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Training set sim_train <- sim_data[1:1000, ] # Validation set sim_val <- sim_data[1001:1200, ]  # Predictors taken as non-linear variables s.vars <- colnames(sim_data)[3:8]  # Model fitting backwardModel <- model_backward(data = sim_train,                                 val.data = sim_val,                                 yvar = \"y\",                                 s.vars = s.vars) #> [1] \"Model 1 fitted!\" # Obtain residuals and fitted values augment(backwardModel) #> # A tibble: 1,200 × 3 #>    Index  .resid .fitted #>    <int>   <dbl>   <dbl> #>  1     6 -0.415    0.996 #>  2     7 -0.176    0.990 #>  3     8  0.700    3.14  #>  4     9 -0.242    1.41  #>  5    10  0.0473   1.01  #>  6    11  0.213    3.24  #>  7    12 -0.113    1.90  #>  8    13 -0.102    1.40  #>  9    14  0.151    2.26  #> 10    15 -0.0155   0.300 #> # ℹ 1,190 more rows"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.gaimFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment function for class gaimFit — augment.gaimFit","title":"Augment function for class gaimFit — augment.gaimFit","text":"Generates residuals fitted values fitted gaimFit object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.gaimFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment function for class gaimFit — augment.gaimFit","text":"","code":"# S3 method for class 'gaimFit' augment(x, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.gaimFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment function for class gaimFit — augment.gaimFit","text":"x gaimFit object. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.gaimFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment function for class gaimFit — augment.gaimFit","text":"tibble.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.gaimFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Augment function for class gaimFit — augment.gaimFit","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1005 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Predictors taken as index variables index.vars <- colnames(sim_data)[3:7]  # Assign group indices for each predictor index.ind = c(rep(1, 3), rep(2, 2))  # Predictors taken as non-linear variables not entering indices s.vars = \"x_lag_005\"  # Model fitting gaimModel <- model_gaim(data = sim_data,                         yvar = \"y\",                         index.vars = index.vars,                         index.ind = index.ind,                         s.vars = s.vars) #> [1] \"model 1\" # Obtain residuals and fitted values augment(gaimModel) #> # A tibble: 1,000 × 3 #>    Index  .resid .fitted #>    <int>   <dbl>   <dbl> #>  1     6  0.160    0.407 #>  2     7 -0.230    0.995 #>  3     8  0.381    3.24  #>  4     9 -0.162    1.41  #>  5    10 -0.0843   0.997 #>  6    11  0.403    3.18  #>  7    12  0.0542   1.80  #>  8    13 -0.0269   1.33  #>  9    14  0.249    2.24  #> 10    15 -0.0629   0.213 #> # ℹ 990 more rows"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.gamFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment function for class gamFit — augment.gamFit","title":"Augment function for class gamFit — augment.gamFit","text":"Generates residuals fitted values fitted gamFit object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.gamFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment function for class gamFit — augment.gamFit","text":"","code":"# S3 method for class 'gamFit' augment(x, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.gamFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment function for class gamFit — augment.gamFit","text":"x gamFit object. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.gamFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment function for class gamFit — augment.gamFit","text":"tibble.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.gamFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Augment function for class gamFit — augment.gamFit","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1005 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Predictors taken as non-linear variables s.vars <- colnames(sim_data)[3:6]  # Predictors taken as linear variables linear.vars <- colnames(sim_data)[7:8]  # Model fitting gamModel <- model_gam(data = sim_data,                       yvar = \"y\",                       s.vars = s.vars,                       linear.vars = linear.vars) #> [1] \"model 1\"  # Obtain residuals and fitted values augment(gamModel) #> # A tibble: 1,000 × 3 #>    Index  .resid .fitted #>    <int>   <dbl>   <dbl> #>  1     6 -0.392    0.959 #>  2     7 -0.219    0.985 #>  3     8  0.515    3.10  #>  4     9 -0.166    1.41  #>  5    10 -0.0998   1.01  #>  6    11  0.356    3.23  #>  7    12 -0.0723   1.92  #>  8    13 -0.0837   1.38  #>  9    14  0.238    2.25  #> 10    15 -0.134    0.283 #> # ℹ 990 more rows"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.lmFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment function for class lmFit — augment.lmFit","title":"Augment function for class lmFit — augment.lmFit","text":"Generates residuals fitted values fitted lmFit object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.lmFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment function for class lmFit — augment.lmFit","text":"","code":"# S3 method for class 'lmFit' augment(x, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.lmFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment function for class lmFit — augment.lmFit","text":"x lmFit object. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.lmFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment function for class lmFit — augment.lmFit","text":"tibble.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.lmFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Augment function for class lmFit — augment.lmFit","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1005 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Predictor variables linear.vars <- colnames(sim_data)[3:8]  # Model fitting lmModel <- model_lm(data = sim_data,                     yvar = \"y\",                     linear.vars = linear.vars) #> [1] \"model 1\" # Obtain residuals and fitted values augment(lmModel) #> # A tibble: 1,000 × 3 #>    Index  .resid .fitted #>    <int>   <dbl>   <dbl> #>  1     6 -0.128    0.695 #>  2     7 -0.292    1.06  #>  3     8  0.613    3.00  #>  4     9 -0.233    1.48  #>  5    10 -0.349    1.26  #>  6    11  0.584    3.00  #>  7    12 -0.187    2.04  #>  8    13 -0.318    1.62  #>  9    14  0.0687   2.42  #> 10    15 -0.0921   0.242 #> # ℹ 990 more rows"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.pprFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment function for class pprFit — augment.pprFit","title":"Augment function for class pprFit — augment.pprFit","text":"Generates residuals fitted values fitted pprFit object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.pprFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment function for class pprFit — augment.pprFit","text":"","code":"# S3 method for class 'pprFit' augment(x, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.pprFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment function for class pprFit — augment.pprFit","text":"x pprFit object. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.pprFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment function for class pprFit — augment.pprFit","text":"tibble.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.pprFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Augment function for class pprFit — augment.pprFit","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1005 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting pprModel <- model_ppr(data = sim_data,                       yvar = \"y\",                       index.vars = index.vars) #> [1] \"model 1\"  # Obtain residuals and fitted values augment(pprModel) #> # A tibble: 1,000 × 3 #>    Index   .resid .fitted #>    <int>    <dbl>   <dbl> #>  1     6  0.0637    0.503 #>  2     7  0.0388    0.726 #>  3     8 -0.0444    3.66  #>  4     9  0.0492    1.20  #>  5    10 -0.0509    0.964 #>  6    11 -0.0312    3.61  #>  7    12  0.00121   1.85  #>  8    13 -0.00829   1.31  #>  9    14  0.00486   2.48  #> 10    15 -0.108     0.258 #> # ℹ 990 more rows"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.smimodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment function for class smimodel — augment.smimodel","title":"Augment function for class smimodel — augment.smimodel","text":"Generates residuals fitted values fitted smimodel object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.smimodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment function for class smimodel — augment.smimodel","text":"","code":"# S3 method for class 'smimodel' augment(x, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.smimodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment function for class smimodel — augment.smimodel","text":"x smimodel object. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.smimodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment function for class smimodel — augment.smimodel","text":"tibble.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.smimodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Augment function for class smimodel — augment.smimodel","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr) library(ROI) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1005 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting smimodel_ppr <- model_smimodel(data = sim_data,                                yvar = \"y\",                                index.vars = index.vars,                                initialise = \"ppr\")  # Obtain residuals and fitted values augment(smimodel_ppr) } # }"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.smimodelFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment function for class smimodelFit — augment.smimodelFit","title":"Augment function for class smimodelFit — augment.smimodelFit","text":"Generates residuals fitted values fitted smimodelFit object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.smimodelFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment function for class smimodelFit — augment.smimodelFit","text":"","code":"# S3 method for class 'smimodelFit' augment(x, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.smimodelFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment function for class smimodelFit — augment.smimodelFit","text":"x smimodelFit object. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/augment.smimodelFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment function for class smimodelFit — augment.smimodelFit","text":"tibble.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/autoplot.smimodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot estimated smooths from a fitted smimodel — autoplot.smimodel","title":"Plot estimated smooths from a fitted smimodel — autoplot.smimodel","text":"Plots graphs fitted spline(s). set multiple models fitted, plots graphs fitted spline(s) specified model (argument model) set multiple models fitted.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/autoplot.smimodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot estimated smooths from a fitted smimodel — autoplot.smimodel","text":"","code":"# S3 method for class 'smimodel' autoplot(object, model = 1, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/autoplot.smimodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot estimated smooths from a fitted smimodel — autoplot.smimodel","text":"object smimodel object. model integer indicate smooths model (set multiple models fitted) plotted. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/autoplot.smimodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot estimated smooths from a fitted smimodel — autoplot.smimodel","text":"Plot(s) fitted spline(s).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/autoplot.smimodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot estimated smooths from a fitted smimodel — autoplot.smimodel","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr) library(ROI) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1005 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting smimodel_ppr <- model_smimodel(data = sim_data,                                yvar = \"y\",                                index.vars = index.vars,                                initialise = \"ppr\")  autoplot(smimodel_ppr) } # }"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/avgCoverage.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate interval forecast coverage — avgCoverage","title":"Calculate interval forecast coverage — avgCoverage","text":"wrapper function conformalForecast::coverage. Calculates mean coverage ifinn matrix prediction intervals validation set. window NULL, matrix rolling means interval forecast coverage also returned.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/avgCoverage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate interval forecast coverage — avgCoverage","text":"","code":"avgCoverage(object, level = 95, window = NULL, na.rm = FALSE)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/avgCoverage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate interval forecast coverage — avgCoverage","text":"object object class bb_cvforecast cb_cvforecast. level Target confidence level prediction intervals. window NULL, rolling mean matrix coverage also returned. na.rm logical indicating whether NA values stripped rolling mean computation proceeds.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/avgCoverage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate interval forecast coverage — avgCoverage","text":"list class coverage following components: mean Mean coverage across validation set. ifinn indicator matrix multivariate time series, \\(h\\)th column holds coverage forecast horizon \\(h\\). time index corresponds period forecast produced. rollmean window NULL, matrix rolling means interval forecast coverage returned.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/avgCoverage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate interval forecast coverage — avgCoverage","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1055 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1050, ]  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting pprModel <- model_ppr(data = sim_train,                       yvar = \"y\",                       index.vars = index.vars)                        # Conformal bootstrap prediction intervals (2-steps-ahead interval forecasts) set.seed(12345) pprModel_cb <- cb_cvforecast(object = pprModel,                              data = sim_data,                              yvar = \"y\",                              predictor.vars = index.vars,                              h = 2,                              ncal = 30,                              num.futures = 100,                              window = 1000)                               # Mean coverage of generated 95% conformal bootstrap prediction intervals cov_data <- avgCoverage(object = pprModel_cb) cov_data$mean } # }"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/avgWidth.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate interval forecast width — avgWidth","title":"Calculate interval forecast width — avgWidth","text":"wrapper function conformalForecast::width. Calculates mean width prediction intervals validation set. window NULL, matrix rolling means interval width also returned. includemedian TRUE, information median interval width returned.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/avgWidth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate interval forecast width — avgWidth","text":"","code":"avgWidth(   object,   level = 95,   includemedian = FALSE,   window = NULL,   na.rm = FALSE )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/avgWidth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate interval forecast width — avgWidth","text":"object object class bb_cvforecast cb_cvforecast. level Target confidence level prediction intervals. includemedian TRUE, median interval width also returned. window NULL, rolling mean (rolling median applicable) matrix interval width also returned. na.rm logical indicating whether NA values stripped rolling mean rolling median computation proceeds.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/avgWidth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate interval forecast width — avgWidth","text":"list class width following components: width Forecast interval width multivariate time series, \\(h\\)th column holds interval width forecast horizon \\(h\\). time index corresponds period forecast produced. mean Mean interval width across validation set. rollmean window NULL, matrix rolling means interval width returned. median Median interval width across validation set. rollmedian window NULL, matrix rolling medians interval width returned.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/avgWidth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate interval forecast width — avgWidth","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1055 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1050, ]  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting pprModel <- model_ppr(data = sim_train,                       yvar = \"y\",                       index.vars = index.vars) #> [1] \"model 1\"                        # Conformal bootstrap prediction intervals (2-steps-ahead interval forecasts) set.seed(12345) pprModel_cb <- cb_cvforecast(object = pprModel,                              data = sim_data,                              yvar = \"y\",                              predictor.vars = index.vars,                              h = 2,                              ncal = 30,                              num.futures = 100,                              window = 1000) #> [1] \"This is 1000\" #> [1] \"This is 1001\" #> [1] \"This is 1002\" #> [1] \"This is 1003\" #> [1] \"This is 1004\" #> [1] \"This is 1005\" #> [1] \"This is 1006\" #> [1] \"This is 1007\" #> [1] \"This is 1008\" #> [1] \"This is 1009\" #> [1] \"This is 1010\" #> [1] \"This is 1011\" #> [1] \"This is 1012\" #> [1] \"This is 1013\" #> [1] \"This is 1014\" #> [1] \"This is 1015\" #> [1] \"This is 1016\" #> [1] \"This is 1017\" #> [1] \"This is 1018\" #> [1] \"This is 1019\" #> [1] \"This is 1020\" #> [1] \"This is 1021\" #> [1] \"This is 1022\" #> [1] \"This is 1023\" #> [1] \"This is 1024\" #> [1] \"This is 1025\" #> [1] \"This is 1026\" #> [1] \"This is 1027\" #> [1] \"This is 1028\" #> [1] \"This is 1029\" #> [1] \"This is 1030\" #> [1] \"This is 1031\" #> [1] \"This is 1032\" #> [1] \"This is 1033\" #> [1] \"This is 1034\" #> [1] \"This is 1035\" #> [1] \"This is 1036\" #> [1] \"This is 1037\" #> [1] \"This is 1038\" #> [1] \"This is 1039\" #> [1] \"This is 1040\" #> [1] \"This is 1041\" #> [1] \"This is 1042\" #> [1] \"This is 1043\" #> [1] \"This is 1044\" #> [1] \"This is 1045\" #> [1] \"This is 1046\" #> [1] \"This is 1047\" #> [1] \"This is 1048\" #> [1] \"This is 30\" #> [1] \"This is 31\" #> [1] \"This is 32\" #> [1] \"This is 33\" #> [1] \"This is 34\" #> [1] \"This is 35\" #> [1] \"This is 36\" #> [1] \"This is 37\" #> [1] \"This is 38\" #> [1] \"This is 39\" #> [1] \"This is 40\" #> [1] \"This is 41\" #> [1] \"This is 42\" #> [1] \"This is 43\" #> [1] \"This is 44\" #> [1] \"This is 45\" #> [1] \"This is 46\" #> [1] \"This is 47\" #> [1] \"This is 48\"                                   # Mean width of generated 95% conformal bootstrap prediction intervals width_data <- avgWidth(object = pprModel_cb) width_data$mean #>       h=1       h=2  #> 0.4185444 0.3772966"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/bb_cvforecast.html","id":null,"dir":"Reference","previous_headings":"","what":"Single season block bootstrap prediction intervals through time series cross-validation forecasting — bb_cvforecast","title":"Single season block bootstrap prediction intervals through time series cross-validation forecasting — bb_cvforecast","text":"Compute prediction intervals applying single season block bootstrap method subsets time series data using rolling forecast origin.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/bb_cvforecast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Single season block bootstrap prediction intervals through time series cross-validation forecasting — bb_cvforecast","text":"","code":"bb_cvforecast(   object,   data,   yvar,   neighbour = 0,   predictor.vars,   h = 1,   season.period = 1,   m = 1,   num.futures = 1000,   level = c(80, 95),   forward = TRUE,   initial = 1,   window = NULL,   roll.length = 1,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colNames = NULL,   na.rm = TRUE,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/bb_cvforecast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Single season block bootstrap prediction intervals through time series cross-validation forecasting — bb_cvforecast","text":"object Fitted model object class smimodel, backward, gaimFit pprFit. data Data set. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). multiple models fitted, grouping variable key tsibble. key specified, dummy key one level created. yvar Name response variable character string. neighbour multiple models fitted: Number neighbours key (.e. grouping variable) considered model fitting handle smoothing key. integer. neighbour =   x, x number keys key interest x number keys key interest grouped together model fitting. default neighbour = 0 (.e. neighbours considered model fitting). predictor.vars character vector names predictor variables. h Forecast horizon. season.period Length seasonal period. m Multiplier. (Block size = NULLseason.period * m) num.futures Number possible future sample paths generated. level Confidence level prediction intervals. forward TRUE, final forecast origin forecasting \\(y_T\\). Otherwise, final forecast origin \\(y_{T-1}\\). initial Initial period time series cross-validation forecasting performed. window Length rolling window. NULL, rolling window used. roll.length Number observations rolling/expanding window rolled forward. exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colNames recursive = TRUE, character vector giving names columns test data filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) data, break lagged variable sequence even intermediate lags used predictors. na.rm logical; TRUE (default), NA NaN's removed sample quantiles computed. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/bb_cvforecast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Single season block bootstrap prediction intervals through time series cross-validation forecasting — bb_cvforecast","text":"object class bb_cvforecast, list contains following elements: x original time series. method character string \"bb_cvforecast\". fit_times number times model fitted cross-validation. mean Point forecasts multivariate time series, \\(h^{th}\\) column holds point forecasts forecast horizon \\(h\\). time index corresponds period forecast produced. res matrix -sample residuals produced cross-validation. number rows corresponds fit_times, row names corresponds time index forecast origin corresponding cross-validation iteration. model_fit Models fitted cross-validation. level confidence values associated prediction intervals. lower list containing lower bounds prediction intervals level. element within list multivariate time series dimensional characteristics mean. upper list containing upper bounds prediction intervals level. element within list multivariate time series dimensional characteristics mean. possible_futures list matrices containing future sample paths generated cross-validation step.","code":""},{"path":[]},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/bb_cvforecast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Single season block bootstrap prediction intervals through time series cross-validation forecasting — bb_cvforecast","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr) library(ROI) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1105 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 +     (0.35*x_lag_002 + 0.7*x_lag_005)^2 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Index variables index.vars <- colnames(sim_data)[3:8]  # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1100, ]  # Model fitting smimodel_ppr <- model_smimodel(data = sim_train,                                yvar = \"y\",                                index.vars = index.vars,                                initialise = \"ppr\")  # Block bootstrap prediction intervals (3-steps-ahead interval forecasts) set.seed(12345) smimodel_ppr_bb <- bb_cvforecast(object = smimodel_ppr,                                  data = sim_data,                                  yvar = \"y\",                                  predictor.vars = index.vars,                                  h = 3,                                  num.futures = 50,                                  window = 1000) } # }"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/blockBootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Futures through single season block bootstrapping — blockBootstrap","title":"Futures through single season block bootstrapping — blockBootstrap","text":"Gerenates possible future sample paths applying single season block bootstrap method.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/blockBootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Futures through single season block bootstrapping — blockBootstrap","text":"","code":"blockBootstrap(   object,   newdata,   resids,   preds,   season.period = 1,   m = 1,   num.futures = 1000,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/blockBootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Futures through single season block bootstrapping — blockBootstrap","text":"object Fitted model object. newdata Test data set. Must data set class tsibble. resids -sample residuals fitted model. preds Predictions test set (.e. data forecast horizon). season.period Length seasonal period. m Multiplier. (Block size = season.period * m) num.futures Number possible future sample paths generated. exclude.trunc names predictor variables truncated stable predictions character string. recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers test data filled forecasts.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/blockBootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Futures through single season block bootstrapping — blockBootstrap","text":"matrix simulated future sample paths.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/cb_cvforecast.html","id":null,"dir":"Reference","previous_headings":"","what":"Conformal bootstrap prediction intervals through time series cross-validation forecasting — cb_cvforecast","title":"Conformal bootstrap prediction intervals through time series cross-validation forecasting — cb_cvforecast","text":"Compute prediction intervals applying conformal bootstrap method subsets time series data using rolling forecast origin.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/cb_cvforecast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conformal bootstrap prediction intervals through time series cross-validation forecasting — cb_cvforecast","text":"","code":"cb_cvforecast(   object,   data,   yvar,   neighbour = 0,   predictor.vars,   h = 1,   ncal = 100,   num.futures = 1000,   level = c(80, 95),   forward = TRUE,   initial = 1,   window = NULL,   roll.length = 1,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colNames = NULL,   na.rm = TRUE,   nacheck_frac_numerator = 2,   nacheck_frac_denominator = 3,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/cb_cvforecast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conformal bootstrap prediction intervals through time series cross-validation forecasting — cb_cvforecast","text":"object Fitted model object class smimodel, backward, gaimFit pprFit. data Data set. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). multiple models fitted, grouping variable key tsibble. key specified, dummy key one level created. yvar Name response variable character string. neighbour multiple models fitted: Number neighbours key (.e. grouping variable) considered model fitting handle smoothing key. integer. neighbour =   x, x number keys key interest x number keys key interest grouped together model fitting. default neighbour = 0 (.e. neighbours considered model fitting). predictor.vars character vector names predictor variables. h Forecast horizon. ncal Length calibration window. num.futures Number possible future sample paths generated bootstrap. level Confidence level prediction intervals. forward TRUE, final forecast origin forecasting \\(y_T\\). Otherwise, final forecast origin \\(y_{T-1}\\). initial Initial period time series cross-validation forecasting performed. window Length rolling window. NULL, rolling window used. roll.length Number observations rolling/expanding window rolled forward. exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colNames recursive = TRUE, character vector giving names columns test data filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) data, break lagged variable sequence even intermediate lags used predictors. na.rm logical; TRUE (default), NA NaN's removed sample quantiles computed. nacheck_frac_numerator Numerator fraction non-missing values required test set. nacheck_frac_denominator Denominator fraction non-missing values required test set. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/cb_cvforecast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conformal bootstrap prediction intervals through time series cross-validation forecasting — cb_cvforecast","text":"object class cb_cvforecast, list contains following elements: x original time series. method character string \"cb_cvforecast\". fit_times number times model fitted cross-validation. mean Point forecasts multivariate time series, \\(h^{th}\\) column holds point forecasts forecast horizon \\(h\\). time index corresponds period forecast produced. error Forecast errors given \\(e_{t+h|t} = y_{t+h} -   \\hat{y}_{t+h|t}\\). res matrix -sample residuals produced cross-validation. level confidence levels associated prediction intervals. cal_times number calibration windows considered cross-validation. num_cal number non-missing multi-step forecast errors calibration window. skip_cal indicator vector indicating whether calibration window skipped without constructing prediction intervals due missing model missing data test set. lower list containing lower bounds prediction intervals level. element within list multivariate time series dimensional characteristics mean. upper list containing upper bounds prediction intervals level. element within list multivariate time series dimensional characteristics mean. possible_futures list matrices containing future sample paths generated calibration step.","code":""},{"path":[]},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/cb_cvforecast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conformal bootstrap prediction intervals through time series cross-validation forecasting — cb_cvforecast","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr) library(ROI) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1105 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 +     (0.35*x_lag_002 + 0.7*x_lag_005)^2 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Index variables index.vars <- colnames(sim_data)[3:8]  # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1100, ]  # Model fitting smimodel_ppr <- model_smimodel(data = sim_train,                                yvar = \"y\",                                index.vars = index.vars,                                initialise = \"ppr\")  # Conformal bootstrap prediction intervals (3-steps-ahead interval forecasts) set.seed(12345) smimodel_ppr_cb <- cb_cvforecast(object = smimodel_ppr,                                  data = sim_data,                                  yvar = \"y\",                                  predictor.vars = index.vars,                                  h = 3,                                  ncal = 30,                                  num.futures = 100,                                  window = 1000) } # }"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/eliminate.html","id":null,"dir":"Reference","previous_headings":"","what":"Eliminate a variable and fit a nonparametric additive model — eliminate","title":"Eliminate a variable and fit a nonparametric additive model — eliminate","text":"Eliminates specified variable fits nonparametric additive model remaining variables, returns validation set MSE. internal function package, designed called model_backward.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/eliminate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Eliminate a variable and fit a nonparametric additive model — eliminate","text":"","code":"eliminate(   ind,   train,   val,   yvar,   family = gaussian(),   s.vars = NULL,   s.basedim = NULL,   linear.vars = NULL,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/eliminate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Eliminate a variable and fit a nonparametric additive model — eliminate","text":"ind integer corresponding position predictor variable eliminated fitting model. (.e. function combine s.vars linear.vars single vector eliminate element corresponding ind.) train data set model(s) trained. Must data set class tsibble. val Validation data set. (data set model selection performed.) Must data set class tsibble. yvar Name response variable character string. family description error distribution link function used model (see glm family). s.vars character vector names predictor variables splines fitted (.e. non-linear predictors). s.basedim Dimension bases used represent smooth terms corresponding s.vars. (information refer mgcv::s().) linear.vars character vector names predictor variables included linearly model (.e. linear predictors). exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable val treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers val.data filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) val.data, break lagged variable sequence even intermediate lags used predictors.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/eliminate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Eliminate a variable and fit a nonparametric additive model — eliminate","text":"numeric.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.backward.html","id":null,"dir":"Reference","previous_headings":"","what":"Forecasting using nonparametric additive models with backward elimination — forecast.backward","title":"Forecasting using nonparametric additive models with backward elimination — forecast.backward","text":"Returns forecasts information nonparametric additive models backward elimination.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.backward.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forecasting using nonparametric additive models with backward elimination — forecast.backward","text":"","code":"# S3 method for class 'backward' forecast(   object,   h = 1,   level = c(80, 95),   newdata,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.backward.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forecasting using nonparametric additive models with backward elimination — forecast.backward","text":"object object class backward. Usually result call model_backward. h Forecast horizon. level Confidence level prediction intervals. newdata set new data forecasts required (.e. test set; tsibble). exclude.trunc names predictor variables truncated stable predictions character string. recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.backward.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forecasting using nonparametric additive models with backward elimination — forecast.backward","text":"object class forecast. , list containing following elements: method name forecasting method character string. model fitted model. mean Point forecasts time series. residuals Residuals fitted model. fitted Fitted values (one-step forecasts).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.backward.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forecasting using nonparametric additive models with backward elimination — forecast.backward","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1215 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Training set sim_train <- sim_data[1:1000, ] # Validation set sim_val <- sim_data[1001:1200, ] # Test set sim_test <- sim_data[1201:1210, ]  # Predictors taken as non-linear variables s.vars <- colnames(sim_data)[3:8]  # Model fitting backwardModel <- model_backward(data = sim_train,                                 val.data = sim_val,                                 yvar = \"y\",                                 s.vars = s.vars) #> [1] \"Model 1 fitted!\" forecast(backwardModel, newdata = sim_test) #>    Point Forecast #> 1       2.8363732 #> 2       1.5316512 #> 3      -0.3403322 #> 4       2.1579572 #> 5       1.1067827 #> 6       0.4067579 #> 7       3.2047193 #> 8       1.5858674 #> 9       0.5086024 #> 10      0.9975114"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.gaimFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Forecasting using GAIMs — forecast.gaimFit","title":"Forecasting using GAIMs — forecast.gaimFit","text":"Returns forecasts information GAIMs.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.gaimFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forecasting using GAIMs — forecast.gaimFit","text":"","code":"# S3 method for class 'gaimFit' forecast(   object,   h = 1,   level = c(80, 95),   newdata,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.gaimFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forecasting using GAIMs — forecast.gaimFit","text":"object object class gaimFit. Usually result call model_gaim. h Forecast horizon. level Confidence level prediction intervals. newdata set new data forecasts required (.e. test set; tsibble). exclude.trunc names predictor variables truncated stable predictions character string. recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.gaimFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forecasting using GAIMs — forecast.gaimFit","text":"object class forecast. , list containing following elements: method name forecasting method character string. model fitted model. mean Point forecasts time series. residuals Residuals fitted model. fitted Fitted values (one-step forecasts).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.gaimFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forecasting using GAIMs — forecast.gaimFit","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1015 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)    # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1010, ]  # Predictors taken as index variables index.vars <- colnames(sim_data)[3:7]  # Assign group indices for each predictor index.ind = c(rep(1, 3), rep(2, 2))  # Predictors taken as non-linear variables not entering indices s.vars = \"x_lag_005\"  # Model fitting gaimModel <- model_gaim(data = sim_train,                         yvar = \"y\",                         index.vars = index.vars,                         index.ind = index.ind,                         s.vars = s.vars) #> [1] \"model 1\"                          forecast(gaimModel, newdata = sim_test) #>    Point Forecast #> 1      1.12501980 #> 2      2.35295038 #> 3      1.43434126 #> 4      0.03578922 #> 5      0.65434928 #> 6      0.49947660 #> 7     -0.01380044 #> 8      0.08583838 #> 9      0.43564545 #> 10    -0.01533303"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.gamFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Forecasting using GAMs — forecast.gamFit","title":"Forecasting using GAMs — forecast.gamFit","text":"Returns forecasts information GAMs.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.gamFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forecasting using GAMs — forecast.gamFit","text":"","code":"# S3 method for class 'gamFit' forecast(   object,   h = 1,   level = c(80, 95),   newdata,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.gamFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forecasting using GAMs — forecast.gamFit","text":"object object class gamFit. Usually result call model_gam. h Forecast horizon. level Confidence level prediction intervals. newdata set new data forecasts required (.e. test set; tsibble). exclude.trunc names predictor variables truncated stable predictions character string. recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.gamFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forecasting using GAMs — forecast.gamFit","text":"object class forecast. , list containing following elements: method name forecasting method character string. model fitted model. mean Point forecasts time series. residuals Residuals fitted model. fitted Fitted values (one-step forecasts).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.gamFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forecasting using GAMs — forecast.gamFit","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1015 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)    # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1010, ]  # Predictors taken as non-linear variables s.vars <- colnames(sim_data)[3:6]  # Predictors taken as linear variables linear.vars <- colnames(sim_data)[7:8]  # Model fitting gamModel <- model_gam(data = sim_train,                       yvar = \"y\",                       s.vars = s.vars,                       linear.vars = linear.vars) #> [1] \"model 1\"  forecast(gamModel, newdata = sim_test) #>    Point Forecast #> 1     1.245005200 #> 2     2.378001533 #> 3     1.659849053 #> 4    -0.228756505 #> 5     0.602818141 #> 6     0.434930625 #> 7     0.026903622 #> 8    -0.002923976 #> 9     0.463371054 #> 10   -0.161817694"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.pprFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Forecasting using PPR models — forecast.pprFit","title":"Forecasting using PPR models — forecast.pprFit","text":"Returns forecasts information PPR models.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.pprFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forecasting using PPR models — forecast.pprFit","text":"","code":"# S3 method for class 'pprFit' forecast(   object,   h = 1,   level = c(80, 95),   newdata,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.pprFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forecasting using PPR models — forecast.pprFit","text":"object object class pprFit. Usually result call model_ppr. h Forecast horizon. level Confidence level prediction intervals. newdata set new data forecasts required (.e. test set; tsibble). exclude.trunc names predictor variables truncated stable predictions character string. recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.pprFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forecasting using PPR models — forecast.pprFit","text":"object class forecast. , list containing following elements: method name forecasting method character string. model fitted model. mean Point forecasts time series. residuals Residuals fitted model. fitted Fitted values (one-step forecasts).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.pprFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forecasting using PPR models — forecast.pprFit","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1015 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)    # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1010, ]  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting pprModel <- model_ppr(data = sim_train,                       yvar = \"y\",                       index.vars = index.vars) #> [1] \"model 1\"  forecast(pprModel, newdata = sim_test) #>    Point Forecast #> 1       1.0193200 #> 2       2.5680536 #> 3       1.2937535 #> 4       0.1206683 #> 5       0.4834984 #> 6       0.5318029 #> 7       0.2111900 #> 8       0.2094600 #> 9       0.4583106 #> 10      0.1576384"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.smimodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Forecasting using SMI models — forecast.smimodel","title":"Forecasting using SMI models — forecast.smimodel","text":"Returns forecasts information SMI models.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.smimodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forecasting using SMI models — forecast.smimodel","text":"","code":"# S3 method for class 'smimodel' forecast(   object,   h = 1,   level = c(80, 95),   newdata,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.smimodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forecasting using SMI models — forecast.smimodel","text":"object object class smimodel. Usually result call model_smimodel. h Forecast horizon. level Confidence level prediction intervals. newdata set new data forecasts required (.e. test set; tsibble). exclude.trunc names predictor variables truncated stable predictions character string. recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.smimodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forecasting using SMI models — forecast.smimodel","text":"object class forecast. , list containing following elements: method name forecasting method character string. model fitted model. mean Point forecasts time series. residuals Residuals fitted model. fitted Fitted values (one-step forecasts).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/forecast.smimodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forecasting using SMI models — forecast.smimodel","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr) library(ROI) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1015 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)    # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1010, ]  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting smimodel_ppr <- model_smimodel(data = sim_train,                                yvar = \"y\",                                index.vars = index.vars,                                initialise = \"ppr\")  forecast(smimodel_ppr, newdata = sim_test) } # }"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/greedy.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Greedy search for tuning penalty parameters — greedy.fit","title":"Greedy search for tuning penalty parameters — greedy.fit","text":"Function perform greedy search given grid penalty parameter combinations (lambda0, lambda2), fits single SMI model best (lowest validation set MSE) penalty parameter combination. optimal combination lies edge grid, penalty parameters adjusted ±10%, second round grid search performed.helper function designed called greedy_smimodel.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/greedy.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Greedy search for tuning penalty parameters — greedy.fit","text":"","code":"greedy.fit(   data,   val.data,   yvar,   neighbour = 0,   family = gaussian(),   index.vars,   initialise = c(\"ppr\", \"additive\", \"linear\", \"multiple\", \"userInput\"),   num_ind = 5,   num_models = 5,   seed = 123,   index.ind = NULL,   index.coefs = NULL,   s.vars = NULL,   linear.vars = NULL,   nlambda = 100,   lambda.min.ratio = 1e-04,   refit = TRUE,   M = 10,   max.iter = 50,   tol = 0.001,   tolCoefs = 0.001,   TimeLimit = Inf,   MIPGap = 1e-04,   NonConvex = -1,   verbose = FALSE,   parallel = FALSE,   workers = NULL,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/greedy.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Greedy search for tuning penalty parameters — greedy.fit","text":"data Training data set models trained. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). val.data Validation data set. (data set penalty parameter selection performed.) Must data set class tsibble. (penalty parameter selection completed, best model re-fitted combined data set data +   val.data.) yvar Name response variable character string. neighbour neighbour argument passed outer function. family description error distribution link function used model (see glm family). index.vars character vector names predictor variables indices estimated. initialise model structure estimation process initialised. default \"ppr\", initial model derived projection pursuit regression. options \"additive\" - nonparametric additive model, \"linear\" - linear regression model (.e. special case single-index model, initial values index coefficients obtained linear regression), \"multiple\" - multiple models fitted starting different initial models (number indices = num_ind; num_models random instances model (.e. predictor assignment indices initial index coefficients generated randomly) considered), final optimal model lowest loss returned, \"userInput\" - user specifies initial model structure (.e. number indices placement index variables among indices) initial index coefficients index.ind index.coefs arguments respectively. num_ind initialise = \"ppr\" \"multiple\": integer specifies number indices used model(s). default num_ind = 5. num_models initialise = \"multiple\": integer specifies number starting models checked. default num_models = 5. seed initialise = \"multiple\": seed set generating random starting points. index.ind initialise = \"userInput\": integer vector assigns group index predictor index.vars. index.coefs initialise = \"userInput\": numeric vector index coefficients. s.vars character vector names predictor variables splines fitted individually (rather considering part index). linear.vars character vector names predictor variables included linearly model. nlambda number values lambda0 (penalty parameter L0 penalty) - default 100. lambda.min.ratio Smallest value lambda0, fraction lambda0.max (data derived). refit Whether refit model combining training validation sets parameter tuning. FALSE, final model estimated training set. M Big-M value used MIP. max.iter Maximum number MIP iterations performed update index coefficients given model. tol Tolerance objective function value (loss) MIP. tolCoefs Tolerance coefficients. TimeLimit limit total time (seconds) expended single MIP iteration. MIPGap Relative MIP optimality gap. NonConvex strategy handling non-convex quadratic objectives non-convex quadratic constraints Gurobi solver. verbose option print detailed solver output. parallel option use parallel processing fitting SMI models different penalty parameter combinations. workers parallel = TRUE: Number cores use. exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable val.data treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers val.data filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) val.data, break lagged variable sequence even intermediate lags used predictors.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/greedy.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Greedy search for tuning penalty parameters — greedy.fit","text":"list contains six elements: initial list information model initialisation. (descriptions list elements see make_smimodelFit). best list information final optimised model. (descriptions list elements see make_smimodelFit). best_lambdas Selected penalty parameter combination. lambda0_seq Sequence values lambda0 used construct initial grid. lambda2_seq Sequence values lambda2 used construct initial grid. searched tibble containing penalty parameter combinations searched two-step greedy search corresponding validation set MSEs.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/greedy_smimodel.html","id":null,"dir":"Reference","previous_headings":"","what":"SMI model estimation through a greedy search for penalty parameters — greedy_smimodel","title":"SMI model estimation through a greedy search for penalty parameters — greedy_smimodel","text":"Performs greedy search given grid penalty parameter combinations (lambda0, lambda2), fits SMI model(s) best (lowest validation set MSE) penalty parameter combination(s). optimal combination lies edge grid, penalty parameters adjusted ±10%, second round grid search performed. grouping variable used, penalty parameters tuned separately individual model.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/greedy_smimodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SMI model estimation through a greedy search for penalty parameters — greedy_smimodel","text":"","code":"greedy_smimodel(   data,   val.data,   yvar,   neighbour = 0,   family = gaussian(),   index.vars,   initialise = c(\"ppr\", \"additive\", \"linear\", \"multiple\", \"userInput\"),   num_ind = 5,   num_models = 5,   seed = 123,   index.ind = NULL,   index.coefs = NULL,   s.vars = NULL,   linear.vars = NULL,   nlambda = 100,   lambda.min.ratio = 1e-04,   refit = TRUE,   M = 10,   max.iter = 50,   tol = 0.001,   tolCoefs = 0.001,   TimeLimit = Inf,   MIPGap = 1e-04,   NonConvex = -1,   verbose = FALSE,   parallel = FALSE,   workers = NULL,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/greedy_smimodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SMI model estimation through a greedy search for penalty parameters — greedy_smimodel","text":"data Training data set models trained. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). multiple models fitted, grouping variable key tsibble. key specified, dummy key one level created. val.data Validation data set. (data set penalty parameter selection performed.) Must data set class tsibble. (penalty parameter selection completed, best model re-fitted combined data set data +   val.data.) yvar Name response variable character string. neighbour multiple models fitted: Number neighbours key (.e. grouping variable) considered model fitting handle smoothing key. integer. neighbour =   x, x number keys key interest x number keys key interest grouped together model fitting. default neighbour = 0 (.e. neighbours considered model fitting). family description error distribution link function used model (see glm family). index.vars character vector names predictor variables indices estimated. initialise model structure estimation process initialised. default \"ppr\", initial model derived projection pursuit regression. options \"additive\" - nonparametric additive model, \"linear\" - linear regression model (.e. special case single-index model, initial values index coefficients obtained linear regression), \"multiple\" - multiple models fitted starting different initial models (number indices = num_ind; num_models random instances model (.e. predictor assignment indices initial index coefficients generated randomly) considered), final optimal model lowest loss returned, \"userInput\" - user specifies initial model structure (.e. number indices placement index variables among indices) initial index coefficients index.ind index.coefs arguments respectively. num_ind initialise = \"ppr\" \"multiple\": integer specifies number indices used model(s). default num_ind = 5. num_models initialise = \"multiple\": integer specifies number starting models checked. default num_models = 5. seed initialise = \"multiple\": seed set generating random starting points. index.ind initialise = \"userInput\": integer vector assigns group index predictor index.vars. index.coefs initialise = \"userInput\": numeric vector index coefficients. s.vars character vector names predictor variables splines fitted individually (rather considering part index). linear.vars character vector names predictor variables included linearly model. nlambda number values lambda0 (penalty parameter L0 penalty) - default 100. lambda.min.ratio Smallest value lambda0, fraction lambda0.max (data derived). refit Whether refit model combining training validation sets parameter tuning. FALSE, final model estimated training set. M Big-M value used MIP. max.iter Maximum number MIP iterations performed update index coefficients given model. tol Tolerance objective function value (loss) MIP. tolCoefs Tolerance coefficients. TimeLimit limit total time (seconds) expended single MIP iteration. MIPGap Relative MIP optimality gap. NonConvex strategy handling non-convex quadratic objectives non-convex quadratic constraints Gurobi solver. verbose option print detailed solver output. parallel option use parallel processing fitting SMI models different penalty parameter combinations. workers parallel = TRUE: Number cores use. exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable val.data treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers val.data filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) val.data, break lagged variable sequence even intermediate lags used predictors.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/greedy_smimodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SMI model estimation through a greedy search for penalty parameters — greedy_smimodel","text":"object class smimodel. tibble two columns: key level grouping variable (.e. key training data set). fit Information fitted model corresponding key. row column fit contains list six elements: initial list information model initialisation. (descriptions list elements see make_smimodelFit). best list information final optimised model. (descriptions list elements see make_smimodelFit). best_lambdas Selected penalty parameter combination. lambda0_seq Sequence values lambda0 used construct initial grid. lambda2_seq Sequence values lambda2 used construct initial grid. searched tibble containing penalty parameter combinations searched two-step greedy search corresponding validation set MSEs. number rows tibble equals number levels grouping variable.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/greedy_smimodel.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"SMI model estimation through a greedy search for penalty parameters — greedy_smimodel","text":"Palihawadana, N.K., Hyndman, R.J. & Wang, X. (2024). Sparse Multiple Index Models High-Dimensional Nonparametric Forecasting. (Department Econometrics Business Statistics Working Paper Series 16/24).","code":""},{"path":[]},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/greedy_smimodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SMI model estimation through a greedy search for penalty parameters — greedy_smimodel","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr) library(ROI) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1205 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Training set sim_train <- sim_data[1:1000, ] # Validation set sim_val <- sim_data[1001:1200, ]  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting smi_greedy <- greedy_smimodel(data = sim_train,                               val.data = sim_val,                               yvar = \"y\",                               index.vars = index.vars,                               initialise = \"ppr\",                               lambda.min.ratio = 0.1)  # Best (optimised) fitted model smi_greedy$fit[[1]]$best  # Selected penalty parameter combination smi_greedy$fit[[1]]$best_lambdas } # }"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/init_alpha.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialising index coefficients — init_alpha","title":"Initialising index coefficients — init_alpha","text":"Initialises index coefficient vector linear regression penalised linear regression.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/init_alpha.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialising index coefficients — init_alpha","text":"","code":"init_alpha(   Y,   X,   index.ind,   init.type = \"penalisedReg\",   lambda0 = 1,   lambda2 = 1,   M = 10 )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/init_alpha.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialising index coefficients — init_alpha","text":"Y Column matrix response. X Matrix predictors entering indices. index.ind integer vector assigns group index predictor. init.type Type initialisation index coefficients. (\"penalisedReg\" - Penalised linear regression; \"reg\" - Linear regression) lambda0 init.type = \"penalisedReg\", penalty parameter L0 penalty. lambda2 init.type = \"penalisedReg\", penalty parameter L2 penalty. M init.type = \"penalisedReg\", big-M value used MIP.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/init_alpha.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialising index coefficients — init_alpha","text":"list containing following components: alpha_init Normalised vector index coefficients. alpha_nonNormalised Non-normalised (.e. prior normalising) vector index coefficients.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/inner_update.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating index coefficients and non-linear functions iteratively — inner_update","title":"Updating index coefficients and non-linear functions iteratively — inner_update","text":"Iteratively updates index coefficients non-linear functions using mixed integer programming. (helper function used within update_smimodelFit; users expected directly call function.)","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/inner_update.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating index coefficients and non-linear functions iteratively — inner_update","text":"","code":"inner_update(   x,   data,   yvar,   family = gaussian(),   index.vars,   s.vars,   linear.vars,   num_ind,   dgz,   alpha_old,   lambda0 = 1,   lambda2 = 1,   M = 10,   max.iter = 50,   tol = 0.001,   TimeLimit = Inf,   MIPGap = 1e-04,   NonConvex = -1,   verbose = FALSE )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/inner_update.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating index coefficients and non-linear functions iteratively — inner_update","text":"x Fitted gam. data Training data set models trained. tsibble. yvar Name response variable character string. family description error distribution link function used model (see glm family). index.vars character vector names predictor variables indices estimated. s.vars character vector names predictor variables splines fitted individually (rather considering part index). linear.vars character vector names predictor variables included linearly model. num_ind Number indices. dgz tibble derivatives estimated smooths. alpha_old Current vector index coefficients. lambda0 Penalty parameter L0 penalty. lambda2 Penalty parameter L2 penalty. M Big-M value used MIP. max.iter Maximum number MIP iterations performed update index coefficients given model. tol Tolerance loss. TimeLimit limit total time (seconds) expended single MIP iteration. MIPGap Relative MIP optimality gap. NonConvex strategy handling non-convex quadratic objectives non-convex quadratic constraints Gurobi solver. verbose option print detailed solver output.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/inner_update.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating index coefficients and non-linear functions iteratively — inner_update","text":"list containing following elements: best_alpha vector best index coefficient estimates. min_loss Minimum value objective function(loss). index.ind integer vector assigns group index predictor, corresponding best_alpha. ind_pos list indicates predictors belong index, corresponding best_alpha. X_new matrix selected predictor variables, corresponding best_alpha.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/lag_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Function for adding lags of time series variables — lag_matrix","title":"Function for adding lags of time series variables — lag_matrix","text":"Generates specified number lagged variables given variable form tibble.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/lag_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function for adding lags of time series variables — lag_matrix","text":"","code":"lag_matrix(variable, n = 10)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/lag_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function for adding lags of time series variables — lag_matrix","text":"variable Variable lagged. n Number lags. default value n = 10.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/lag_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function for adding lags of time series variables — lag_matrix","text":"tibble.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/lag_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function for adding lags of time series variables — lag_matrix","text":"","code":"library(dplyr) library(tibble) library(tidyr) # Adding lagged variables to an existing tibble set.seed(123) sim_data <- tibble(x_lag_000 = runif(100)) |>   mutate(x_lag = lag_matrix(x_lag_000, 3)) |>   unpack(x_lag, names_sep = \"_\")"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/loss.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculating the loss of the MIP used to estimate a SMI model — loss","title":"Calculating the loss of the MIP used to estimate a SMI model — loss","text":"Calculates value objective function (loss function) mixed integer program used estimate SMI model.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/loss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculating the loss of the MIP used to estimate a SMI model — loss","text":"","code":"loss(Y, Yhat, alpha, lambda0, lambda2)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/loss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculating the loss of the MIP used to estimate a SMI model — loss","text":"Y Column matrix response. Yhat Predicted value response. alpha Vector index coefficients. lambda0 Penalty parameter L0 penalty. lambda2 Penalty parameter L2 penalty.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/loss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculating the loss of the MIP used to estimate a SMI model — loss","text":"numeric.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/make_smimodelFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Converting a fitted gam object to a smimodelFit object — make_smimodelFit","title":"Converting a fitted gam object to a smimodelFit object — make_smimodelFit","text":"Converts given object class gam object class smimodelFit.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/make_smimodelFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converting a fitted gam object to a smimodelFit object — make_smimodelFit","text":"","code":"make_smimodelFit(   x,   data,   yvar,   neighbour,   index.vars,   index.ind,   index.data,   index.names,   alpha,   s.vars = NULL,   linear.vars = NULL,   lambda0 = NULL,   lambda2 = NULL,   M = NULL,   max.iter = NULL,   tol = NULL,   tolCoefs = NULL,   TimeLimit = NULL,   MIPGap = NULL,   NonConvex = NULL )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/make_smimodelFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converting a fitted gam object to a smimodelFit object — make_smimodelFit","text":"x fitted gam object. data original training data set. yvar Name response variable character string. neighbour neighbour argument passed outer function. index.vars character vector names predictor variables indices estimated. index.ind integer vector assigns group index predictor index.vars. index.data tibble including columns constructed indices. index.names character vector names constructed indices. alpha vector index coefficients. s.vars character vector names predictor variables splines fitted individually (rather considering part index). linear.vars character vector names predictor variables included linearly model. lambda0 Penalty parameter L0 penalty. lambda2 Penalty parameter L2 penalty. M Big-M value used MIP. max.iter Maximum number MIP iterations performed update index coefficients given model. tol Tolerance objective function value (loss) MIP. tolCoefs Tolerance coefficients. TimeLimit limit total time (seconds) expended single MIP iteration. MIPGap Relative MIP optimality gap. NonConvex strategy handling non-convex quadratic objectives non-convex quadratic constraints Gurobi solver.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/make_smimodelFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converting a fitted gam object to a smimodelFit object — make_smimodelFit","text":"object class smimodelFit, list contains following elements: alpha sparse matrix index coefficients vectors. column matrix corresponds index coefficient vector index. derivatives tibble derivatives estimated smooths. var_y Name response variable. vars_index character vector names predictor variables indices estimated. vars_s character vector names predictor variables splines fitted individually. vars_linear character vector names predictor variables included linearly model. neighbour Number neighbours key considered model fitting. gam Fitted gam. lambda0 L0 penalty parameter used model fitting. lambda2 L2 penalty parameter used model fitting. M Big-M value used MIP. max.iter Maximum number MIP iterations single round index coefficients update. tol Tolerance objective function value (loss) used solving MIP. tolCoefs Tolerance coefficients used updating index coefficients. TimeLimit Limit total time (seconds) expended single MIP iteration. MIPGap Relative MIP optimality gap used. Nonconvex strategy used handling non-convex quadratic objectives non-convex quadratic constraints Gurobi solver.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_backward.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonparametric Additive Model with Backward Elimination — model_backward","title":"Nonparametric Additive Model with Backward Elimination — model_backward","text":"Fits nonparametric additive model, simultaneous variable selection backward elimination procedure proposed Fan Hyndman (2012).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_backward.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nonparametric Additive Model with Backward Elimination — model_backward","text":"","code":"model_backward(   data,   val.data,   yvar,   neighbour = 0,   family = gaussian(),   s.vars = NULL,   s.basedim = NULL,   linear.vars = NULL,   refit = TRUE,   tol = 0.001,   parallel = FALSE,   workers = NULL,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_backward.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonparametric Additive Model with Backward Elimination — model_backward","text":"data Training data set models trained. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). multiple models fitted, grouping variable key tsibble. key specified, dummy key one level created. val.data Validation data set. (data set model selection performed.) Must data set class tsibble. yvar Name response variable character string. neighbour multiple models fitted: Number neighbours key (.e. grouping variable) considered model fitting handle smoothing key. integer. neighbour =   x, x number keys key interest x number keys key interest grouped together model fitting. default neighbour = 0 (.e. neighbours considered model fitting). family description error distribution link function used model (see glm family). s.vars character vector names predictor variables splines fitted (.e. non-linear predictors). s.basedim Dimension bases used represent smooth terms corresponding s.vars. (information refer mgcv::s().) linear.vars character vector names predictor variables included linearly model (.e. linear predictors). refit Whether refit model combining training validation sets model selection. FALSE, final model estimated training set. tol Tolerance ratio relative change validation set MSE, used model selection. parallel Whether use parallel computing model selection . workers parallel = TRUE, number workers use. exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable val.data treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers val.data filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) val.data, break lagged variable sequence even intermediate lags used predictors.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_backward.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nonparametric Additive Model with Backward Elimination — model_backward","text":"object class backward. tibble two columns: key level grouping variable (.e. key training data set). fit Information fitted model corresponding key. row column fit object class gam. details refer mgcv::gamObject.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_backward.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nonparametric Additive Model with Backward Elimination — model_backward","text":"function fits nonparametric additive model formulated Backward Elimination, proposed Fan Hyndman (2012). process starts predictors included additive model, predictors progressively omitted best model obtained based validation set. best model obtained, final model re-fitted data set combining training validation sets. details see reference.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_backward.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nonparametric Additive Model with Backward Elimination — model_backward","text":"Fan, S. & Hyndman, R.J. (2012). Short-Term Load Forecasting Based Semi-Parametric Additive Model. IEEE Transactions Power Systems, 27(1), 134-141.doi:10.1109/TPWRS.2011.2162082 .","code":""},{"path":[]},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_backward.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nonparametric Additive Model with Backward Elimination — model_backward","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1205 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Training set sim_train <- sim_data[1:1000, ] # Validation set sim_val <- sim_data[1001:1200, ]  # Predictors taken as non-linear variables s.vars <- colnames(sim_data)[3:8]  # Model fitting backwardModel <- model_backward(data = sim_train,                                 val.data = sim_val,                                 yvar = \"y\",                                 s.vars = s.vars) #> [1] \"Model 1 fitted!\" # Fitted model backwardModel$fit[[1]] #>  #> Family: gaussian  #> Link function: identity  #>  #> Formula: #> y ~ +s(x_lag_000, bs = \"cr\") + s(x_lag_001, bs = \"cr\") + s(x_lag_002,  #>     bs = \"cr\") + s(x_lag_003, bs = \"cr\") + s(x_lag_005, bs = \"cr\") #>  #> Estimated degrees of freedom: #> 4.80 3.51 1.00 3.28 1.00  total = 14.59  #>  #> REML score: 480.794"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_gaim.html","id":null,"dir":"Reference","previous_headings":"","what":"Groupwise Additive Index Models (GAIM) — model_gaim","title":"Groupwise Additive Index Models (GAIM) — model_gaim","text":"wrapper cgaim::cgaim() enabling multiple GAIM models based grouping variable. Currently support Constrained GAIM (CGAIM)s.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_gaim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Groupwise Additive Index Models (GAIM) — model_gaim","text":"","code":"model_gaim(   data,   yvar,   neighbour = 0,   index.vars,   index.ind,   s.vars = NULL,   linear.vars = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_gaim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Groupwise Additive Index Models (GAIM) — model_gaim","text":"data Training data set models trained. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). multiple models fitted, grouping variable key tsibble. key specified, dummy key one level created. yvar Name response variable character string. neighbour multiple models fitted: Number neighbours key (.e. grouping variable) considered model fitting handle smoothing key. integer. neighbour =   x, x number keys key interest x number keys key interest grouped together model fitting. default neighbour = 0 (.e. neighbours considered model fitting). index.vars character vector names predictor variables indices estimated. index.ind integer vector assigns group index predictor index.vars. s.vars character vector names predictor variables splines fitted individually (rather considering part index). linear.vars character vector names predictor variables included linearly model. ... arguments currently used. (Note arguments cgaim::cgaim() related constrained GAIMs currently supported. Furthermore, argument subset also supported due bug cgaim::cgaim().)","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_gaim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Groupwise Additive Index Models (GAIM) — model_gaim","text":"object class gaimFit. tibble two columns: key level grouping variable (.e. key training data set). fit Information fitted model corresponding key. row column fit object class cgaim. details refer cgaim::cgaim().","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_gaim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Groupwise Additive Index Models (GAIM) — model_gaim","text":"Group-wise Additive Index Model (GAIM) can written form $$y_{} = \\sum_{j = 1}^{p} g_{j}(\\boldsymbol{\\alpha}_{j}^{T}\\boldsymbol{x}_{ij}) + \\varepsilon_{}, \\quad = 1, \\dots, n,$$ \\(y_{}\\) univariate response, \\(\\boldsymbol{x}_{ij} \\\\mathbb{R}^{l{j}}\\), \\(j = 1,   \\dots, p\\) pre-specified non-overlapping subsets \\(\\boldsymbol{x}_{}\\), \\(\\boldsymbol{\\alpha}_j\\) corresponding index coefficients, \\(g_{j}\\) unknown (possibly nonlinear) component function, \\(\\varepsilon_{}\\) random error, independent \\(\\boldsymbol{x}_{}\\).","code":""},{"path":[]},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_gaim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Groupwise Additive Index Models (GAIM) — model_gaim","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1005 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Predictors taken as index variables index.vars <- colnames(sim_data)[3:7]  # Assign group indices for each predictor index.ind = c(rep(1, 3), rep(2, 2))  # Predictors taken as non-linear variables not entering indices s.vars = \"x_lag_005\"  # Model fitting gaimModel <- model_gaim(data = sim_data,                         yvar = \"y\",                         index.vars = index.vars,                         index.ind = index.ind,                         s.vars = s.vars) #> [1] \"model 1\" # Fitted model gaimModel$fit[[1]] #> Formula: #> y ~ g(x_lag_000, x_lag_001, x_lag_002) + g(x_lag_003, x_lag_004) +  #>     s(x_lag_005) #>  #> Coefficients: #> (Intercept)   x_lag_000   x_lag_003   x_lag_005  #>  1.23026577  0.99071595  0.41458553  0.03298014  #>  #> Indices weights: #> x_lag_000  #>   x_lag_000   x_lag_001   x_lag_002  #> 0.604670638 0.392787126 0.002542237  #> x_lag_003  #>   x_lag_003   x_lag_004  #>  0.98152724 -0.01847276  #>  #> Residual sum of squares: 0.06248322"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalised Additive Models — model_gam","title":"Generalised Additive Models — model_gam","text":"wrapper mgcv::gam() enabling multiple GAMs based grouping variable.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalised Additive Models — model_gam","text":"","code":"model_gam(   data,   yvar,   family = gaussian(),   neighbour = 0,   s.vars,   s.basedim = NULL,   linear.vars = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalised Additive Models — model_gam","text":"data Training data set models trained. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). multiple models fitted, grouping variable key tsibble. key specified, dummy key one level created. yvar Name response variable character string. family description error distribution link function used model (see glm family). neighbour multiple models fitted: Number neighbours key (.e. grouping variable) considered model fitting handle smoothing key. integer. neighbour =   x, x number keys key interest x number keys key interest grouped together model fitting. default neighbour = 0 (.e. neighbours considered model fitting). s.vars character vector names predictor variables splines fitted (.e. non-linear predictors). s.basedim Dimension bases used represent smooth terms corresponding s.vars. (information refer mgcv::s().) linear.vars character vector names predictor variables included linearly model (.e. linear predictors). ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalised Additive Models — model_gam","text":"object class gamFit. tibble two columns: key level grouping variable (.e. key training data set). fit Information fitted model corresponding key. row column fit object class gam. details refer mgcv::gamObject.","code":""},{"path":[]},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_gam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalised Additive Models — model_gam","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1005 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Predictors taken as non-linear variables s.vars <- colnames(sim_data)[3:6]  # Predictors taken as linear variables linear.vars <- colnames(sim_data)[7:8]  # Model fitting gamModel <- model_gam(data = sim_data,                       yvar = \"y\",                       s.vars = s.vars,                       linear.vars = linear.vars) #> [1] \"model 1\"  # Fitted model gamModel$fit[[1]] #>  #> Family: gaussian  #> Link function: identity  #>  #> Formula: #> y ~ s(x_lag_000, bs = \"cr\") + s(x_lag_001, bs = \"cr\") + s(x_lag_002,  #>     bs = \"cr\") + s(x_lag_003, bs = \"cr\") + x_lag_004 + x_lag_005 #>  #> Estimated degrees of freedom: #> 4.62 3.51 1.39 2.41  total = 14.93  #>  #> REML score: 397.9157"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear Regression models — model_lm","title":"Linear Regression models — model_lm","text":"wrapper lm enabling multiple linear models based grouping variable.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear Regression models — model_lm","text":"","code":"model_lm(data, yvar, neighbour = 0, linear.vars, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear Regression models — model_lm","text":"data Training data set models trained. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). multiple models fitted, grouping variable key tsibble. key specified, dummy key one level created. yvar Name response variable character string. neighbour multiple models fitted: Number neighbours key (.e. grouping variable) considered model fitting handle smoothing key. integer. neighbour =   x, x number keys key interest x number keys key interest grouped together model fitting. default neighbour = 0 (.e. neighbours considered model fitting). linear.vars character vector names predictor variables. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Linear Regression models — model_lm","text":"object class lmFit. tibble two columns: key level grouping variable (.e. key training data set). fit Information fitted model corresponding key. row column fit object class lm. details refer stats::lm.","code":""},{"path":[]},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_lm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linear Regression models — model_lm","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1005 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Predictor variables linear.vars <- colnames(sim_data)[3:8]  # Model fitting lmModel <- model_lm(data = sim_data,                     yvar = \"y\",                     linear.vars = linear.vars) #> [1] \"model 1\" # Fitted model lmModel$fit[[1]] #>  #> Call: #> stats::lm(formula = as.formula(pre.formula), data = df_cat) #>  #> Coefficients: #> (Intercept)    x_lag_000    x_lag_001    x_lag_002    x_lag_003    x_lag_004   #>   -1.793753     2.770954     1.821332     0.048464     1.414372     0.038152   #>   x_lag_005   #>   -0.006478   #>"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_ppr.html","id":null,"dir":"Reference","previous_headings":"","what":"Projection Pursuit Regression (PPR) models — model_ppr","title":"Projection Pursuit Regression (PPR) models — model_ppr","text":"wrapper stats::ppr() enabling multiple PPR models based grouping variable.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_ppr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Projection Pursuit Regression (PPR) models — model_ppr","text":"","code":"model_ppr(data, yvar, neighbour = 0, index.vars, num_ind = 5, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_ppr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Projection Pursuit Regression (PPR) models — model_ppr","text":"data Training data set models trained. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). multiple models fitted, grouping variable key tsibble. key specified, dummy key one level created. yvar Name response variable character string. neighbour multiple models fitted: Number neighbours key (.e. grouping variable) considered model fitting handle smoothing key. integer. neighbour =   x, x number keys key interest x number keys key interest grouped together model fitting. default neighbour = 0 (.e. neighbours considered model fitting). index.vars character vector names predictor variables indices estimated. num_ind integer specifies number indices used model(s). (Corresponds nterms stats::ppr().) ... arguments currently used. (information arguments can passed, refer stats::ppr().)","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_ppr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Projection Pursuit Regression (PPR) models — model_ppr","text":"object class pprFit. tibble two columns: key level grouping variable (.e. key training data set). fit Information fitted model corresponding key. row column fit object class c(\"ppr.form\", \"ppr\"). details refer stats::ppr().","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_ppr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Projection Pursuit Regression (PPR) models — model_ppr","text":"Projection Pursuit Regression (PPR) model (Friedman & Stuetzle (1981)) given $$y_{} = \\sum_{j=1}^{p} {g_{j}(\\boldsymbol{\\alpha}_{j}^{T}\\boldsymbol{x}_{})} + \\varepsilon_{}, \\quad = 1, \\dots, n,$$ \\(y_{}\\) response, \\(\\boldsymbol{x}_{}\\) \\(q\\)-dimensional predictor vector, \\(\\boldsymbol{\\alpha}_{j} = ( \\alpha_{j1}, \\dots, \\alpha_{jp} )^{T}\\), \\(j = 1, \\dots, p\\) \\(q\\)-dimensional projection vectors (vectors \"index coefficients\"), \\(g_{j}\\)'s unknown nonlinear functions, \\(\\varepsilon_{}\\) random error.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_ppr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Projection Pursuit Regression (PPR) models — model_ppr","text":"Friedman, J. H. & Stuetzle, W. (1981). Projection pursuit regression. Journal American Statistical Association, 76, 817–823. doi:10.2307/2287576 .","code":""},{"path":[]},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_ppr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Projection Pursuit Regression (PPR) models — model_ppr","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1005 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting pprModel <- model_ppr(data = sim_data,                       yvar = \"y\",                       index.vars = index.vars) #> [1] \"model 1\"  # Fitted model pprModel$fit[[1]] #> Call: #> ppr(formula = as.formula(pre.formula), data = df_cat, nterms = num_ind) #>  #> Goodness of fit: #>  5 terms  #> 9.210028"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_smimodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Sparse Multiple Index (SMI) Models — model_smimodel","title":"Sparse Multiple Index (SMI) Models — model_smimodel","text":"Fits nonparametric multiple index model(s), simultaneous predictor selection (hence \"sparse\") predictor grouping. Possible fit multiple SMI models based grouping variable.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_smimodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sparse Multiple Index (SMI) Models — model_smimodel","text":"","code":"model_smimodel(   data,   yvar,   neighbour = 0,   family = gaussian(),   index.vars,   initialise = c(\"ppr\", \"additive\", \"linear\", \"multiple\", \"userInput\"),   num_ind = 5,   num_models = 5,   seed = 123,   index.ind = NULL,   index.coefs = NULL,   s.vars = NULL,   linear.vars = NULL,   lambda0 = 1,   lambda2 = 1,   M = 10,   max.iter = 50,   tol = 0.001,   tolCoefs = 0.001,   TimeLimit = Inf,   MIPGap = 1e-04,   NonConvex = -1,   verbose = FALSE )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_smimodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sparse Multiple Index (SMI) Models — model_smimodel","text":"data Training data set models trained. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). multiple models fitted, grouping variable key tsibble. key specified, dummy key one level created. yvar Name response variable character string. neighbour multiple models fitted: Number neighbours key (.e. grouping variable) considered model fitting handle smoothing key. integer. neighbour =   x, x number keys key interest x number keys key interest grouped together model fitting. default neighbour = 0 (.e. neighbours considered model fitting). family description error distribution link function used model (see glm family). index.vars character vector names predictor variables indices estimated. initialise model structure estimation process initialised. default \"ppr\", initial model derived projection pursuit regression. options \"additive\" - nonparametric additive model, \"linear\" - linear regression model (.e. special case single-index model, initial values index coefficients obtained linear regression), \"multiple\" - multiple models fitted starting different initial models (number indices = num_ind; num_models random instances model (.e. predictor assignment indices initial index coefficients generated randomly) considered), final optimal model lowest loss returned, \"userInput\" - user specifies initial model structure (.e. number indices placement index variables among indices) initial index coefficients index.ind index.coefs arguments respectively. num_ind initialise = \"ppr\" \"multiple\": integer specifies number indices used model(s). default num_ind = 5. num_models initialise = \"multiple\": integer specifies number starting models checked. default num_models = 5. seed initialise = \"multiple\": seed set generating random starting points. index.ind initialise = \"userInput\": integer vector assigns group index predictor index.vars. index.coefs initialise = \"userInput\": numeric vector index coefficients. s.vars character vector names predictor variables splines fitted individually (rather considering part index). linear.vars character vector names predictor variables included linearly model. lambda0 Penalty parameter L0 penalty. lambda2 Penalty parameter L2 penalty. M Big-M value used MIP. max.iter Maximum number MIP iterations performed update index coefficients given model. tol Tolerance objective function value (loss) MIP. tolCoefs Tolerance coefficients. TimeLimit limit total time (seconds) expended single MIP iteration. MIPGap Relative MIP optimality gap. NonConvex strategy handling non-convex quadratic objectives non-convex quadratic constraints Gurobi solver. verbose option print detailed solver output.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_smimodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sparse Multiple Index (SMI) Models — model_smimodel","text":"object class smimodel. tibble two columns: key level grouping variable (.e. key training data set). fit Information fitted model corresponding key. row column fit contains list two elements: initial list information model initialisation. (descriptions list elements see make_smimodelFit). best list information final optimised model. (descriptions list elements see make_smimodelFit).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_smimodel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sparse Multiple Index (SMI) Models — model_smimodel","text":"Sparse Multiple Index (SMI) model semi-parametric model can written $$y_{} = \\beta_{0} + \\sum_{j = 1}^{p}g_{j}(\\boldsymbol{\\alpha}_{j}^{T}\\boldsymbol{x}_{ij}) + \\sum_{k = 1}^{d}f_{k}(w_{ik}) + \\boldsymbol{\\theta}^{T}\\boldsymbol{u}_{} + \\varepsilon_{}, \\quad = 1, \\dots, n,$$ \\(y_{}\\) univariate response, \\(\\beta_{0}\\) model intercept, \\(\\boldsymbol{x}_{ij} \\\\mathbb{R}^{l_{j}}\\), \\(j = 1, \\dots, p\\) \\(p\\) subsets predictors entering indices, \\(\\boldsymbol{\\alpha}_{j}\\) vector index coefficients corresponding index \\(h_{ij} =   \\boldsymbol{\\alpha}_{j}^{T}\\boldsymbol{x}_{ij}\\), \\(g_{j}\\) smooth nonlinear function (estimated penalised cubic regression spline). model also allows predictors enter indices, including covariates \\(w_{ik}\\) relate response nonlinear functions \\(f_{k}\\), \\(k = 1, \\dots, d\\), linear covariates \\(\\boldsymbol{u}_{}\\). model formulation related implementation, number indices \\(p\\) predictor grouping among indices assumed unknown prior model estimation. Suppose observe \\(y_1,\\dots,y_n\\), along set potential predictors, \\(\\boldsymbol{x}_1,\\dots,\\boldsymbol{x}_n\\), vector \\(\\boldsymbol{x}_i\\) containing \\(q\\) predictors. function implements algorithmic variable selection index variables (.e. predictors entering indices) SMI model allowing zero index coefficients predictors. Non-overlapping predictors among indices assumed (.e. predictor enters one index). algorithmic details see reference.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_smimodel.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sparse Multiple Index (SMI) Models — model_smimodel","text":"Palihawadana, N.K., Hyndman, R.J. & Wang, X. (2024). Sparse Multiple Index Models High-Dimensional Nonparametric Forecasting. (Department Econometrics Business Statistics Working Paper Series 16/24).","code":""},{"path":[]},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/model_smimodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sparse Multiple Index (SMI) Models — model_smimodel","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr) library(ROI) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1005 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting smimodel_ppr <- model_smimodel(data = sim_data,                                yvar = \"y\",                                index.vars = index.vars,                                initialise = \"ppr\")  # Best (optimised) fitted model smimodel_ppr$fit[[1]]$best } # }"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/new_smimodelFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor function for the class smimodelFit — new_smimodelFit","title":"Constructor function for the class smimodelFit — new_smimodelFit","text":"Constructs object class smimodelFit using information passed arguments.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/new_smimodelFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor function for the class smimodelFit — new_smimodelFit","text":"","code":"new_smimodelFit(   data,   yvar,   neighbour = 0,   family = gaussian(),   index.vars,   initialise = c(\"additive\", \"linear\", \"userInput\"),   index.ind = NULL,   index.coefs = NULL,   s.vars = NULL,   linear.vars = NULL )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/new_smimodelFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor function for the class smimodelFit — new_smimodelFit","text":"data Training data set models trained. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). yvar Name response variable character string. neighbour neighbour argument passed outer function. family description error distribution link function used model (see glm family). index.vars character vector names predictor variables indices estimated. initialise model structure estimation process initialised. default \"additive\", initial model nonparametric additive model. options \"linear\" - linear regression model (.e. special case single-index model, initial values index coefficients obtained linear regression), \"userInput\" - user specifies initial model structure (.e. number indices placement index variables among indices) initial index coefficients index.ind index.coefs arguments respectively. index.ind initialise = \"userInput\": integer vector assigns group index predictor index.vars. index.coefs initialise = \"userInput\": numeric vector index coefficients. s.vars character vector names predictor variables splines fitted individually (rather considering part index). linear.vars character vector names predictor variables included linearly model.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/new_smimodelFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor function for the class smimodelFit — new_smimodelFit","text":"list initial model information. descriptions list elements see make_smimodelFit).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/normalise_alpha.html","id":null,"dir":"Reference","previous_headings":"","what":"Scaling index coefficient vectors to have unit norm — normalise_alpha","title":"Scaling index coefficient vectors to have unit norm — normalise_alpha","text":"Scales coefficient vector particular index unit norm.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/normalise_alpha.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scaling index coefficient vectors to have unit norm — normalise_alpha","text":"","code":"normalise_alpha(alpha)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/normalise_alpha.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scaling index coefficient vectors to have unit norm — normalise_alpha","text":"alpha vector index coefficients.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/normalise_alpha.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scaling index coefficient vectors to have unit norm — normalise_alpha","text":"numeric vector.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/point_measures.html","id":null,"dir":"Reference","previous_headings":"","what":"Point estimate accuracy measures — MAE","title":"Point estimate accuracy measures — MAE","text":"Point estimate accuracy measures","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/point_measures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Point estimate accuracy measures — MAE","text":"","code":"MAE(residuals, na.rm = TRUE, ...)  MSE(residuals, na.rm = TRUE, ...)  point_measures"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/point_measures.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Point estimate accuracy measures — MAE","text":"object class list length 2.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/point_measures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Point estimate accuracy measures — MAE","text":"residuals vector residuals either validation test data. na.rm TRUE, remove missing values calculating accuracy measure. ... Additional arguments measure.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/point_measures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Point estimate accuracy measures — MAE","text":"individual functions (MAE, MSE), returns single numeric scalar giving requested accuracy measure. exported object point_measures, returns named list functions can supplied higher-level accuracy routines.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/point_measures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Point estimate accuracy measures — MAE","text":"","code":"set.seed(123) ytrain <- rnorm(100) ytest  <- rnorm(30) yhat   <- ytest + rnorm(30, sd = 0.3) resid   <- ytest - yhat  MAE(resid) #> [1] 0.2840219 MSE(resid) #> [1] 0.1116308"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/possibleFutures_benchmark.html","id":null,"dir":"Reference","previous_headings":"","what":"Possible future sample paths (multi-step) from residuals of a fitted benchmark model — possibleFutures_benchmark","title":"Possible future sample paths (multi-step) from residuals of a fitted benchmark model — possibleFutures_benchmark","text":"Generates possible future sample paths (multi-step) using residuals fitted benchmark model recursive forecasting.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/possibleFutures_benchmark.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Possible future sample paths (multi-step) from residuals of a fitted benchmark model — possibleFutures_benchmark","text":"","code":"possibleFutures_benchmark(   object,   newdata,   bootstraps,   exclude.trunc = NULL,   recursive_colRange )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/possibleFutures_benchmark.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Possible future sample paths (multi-step) from residuals of a fitted benchmark model — possibleFutures_benchmark","text":"object fitted model object class backward, pprFit, gaimFit. newdata set new data forecasts required (.e. test set; tsibble). bootstraps Generated matrix bootstrapped residual series. exclude.trunc names predictor variables truncated stable predictions character string. recursive_colRange range column numbers newdata filled forecasts.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/possibleFutures_benchmark.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Possible future sample paths (multi-step) from residuals of a fitted benchmark model — possibleFutures_benchmark","text":"list containing following components: firstFuture numeric vector 1-step-ahead simulated futures. future_cols list multi-steps-ahead simulated futures, list element corresponds 1-step-ahead simulated future firstFuture.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/possibleFutures_smimodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Possible future sample paths (multi-step) from smimodel residuals — possibleFutures_smimodel","title":"Possible future sample paths (multi-step) from smimodel residuals — possibleFutures_smimodel","text":"Generates possible future sample paths (multi-step) using residuals fitted smimodel recursive forecasting.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/possibleFutures_smimodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Possible future sample paths (multi-step) from smimodel residuals — possibleFutures_smimodel","text":"","code":"possibleFutures_smimodel(   object,   newdata,   bootstraps,   exclude.trunc = NULL,   recursive_colRange )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/possibleFutures_smimodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Possible future sample paths (multi-step) from smimodel residuals — possibleFutures_smimodel","text":"object smimodel object. newdata set new data forecasts required (.e. test set; tsibble). bootstraps Generated matrix bootstrapped residual series. exclude.trunc names predictor variables truncated stable predictions character string. recursive_colRange range column numbers newdata filled forecasts.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/possibleFutures_smimodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Possible future sample paths (multi-step) from smimodel residuals — possibleFutures_smimodel","text":"list containing following components: firstFuture numeric vector 1-step-ahead simulated futures. future_cols list multi-steps-ahead simulated futures, list element corresponds 1-step-ahead simulated future firstFuture.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.backward.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtaining forecasts on a test set from a fitted backward — predict.backward","title":"Obtaining forecasts on a test set from a fitted backward — predict.backward","text":"Gives forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.backward.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtaining forecasts on a test set from a fitted backward — predict.backward","text":"","code":"# S3 method for class 'backward' predict(   object,   newdata,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.backward.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtaining forecasts on a test set from a fitted backward — predict.backward","text":"object backward object. newdata set new data forecasts required (.e. test set; tsibble). exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable newdata treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) newdata, break lagged variable sequence even intermediate lags used predictors. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.backward.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtaining forecasts on a test set from a fitted backward — predict.backward","text":"tsibble forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.backward.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtaining forecasts on a test set from a fitted backward — predict.backward","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1215 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Training set sim_train <- sim_data[1:1000, ] # Validation set sim_val <- sim_data[1001:1200, ] # Test set sim_test <- sim_data[1201:1210, ]  # Predictors taken as non-linear variables s.vars <- colnames(sim_data)[3:8]  # Model fitting backwardModel <- model_backward(data = sim_train,                                 val.data = sim_val,                                 yvar = \"y\",                                 s.vars = s.vars) #> [1] \"Model 1 fitted!\" predict(object = backwardModel, newdata = sim_test) #> # A tsibble: 10 x 10 [1] #> # Key:       dummy_key [1] #>    inddd      y x_lag_000 x_lag_001 x_lag_002 x_lag_003 x_lag_004 x_lag_005 #>    <int>  <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl> #>  1  1206 2.93      0.989     0.487     0.718     0.489     0.887     0.859  #>  2  1207 0.841     0.0648    0.989     0.487     0.718     0.489     0.887  #>  3  1208 0.0602    0.158     0.0648    0.989     0.487     0.718     0.489  #>  4  1209 1.89      0.785     0.158     0.0648    0.989     0.487     0.718  #>  5  1210 1.01      0.542     0.785     0.158     0.0648    0.989     0.487  #>  6  1211 0.451     0.417     0.542     0.785     0.158     0.0648    0.989  #>  7  1212 3.39      0.999     0.417     0.542     0.785     0.158     0.0648 #>  8  1213 1.29      0.256     0.999     0.417     0.542     0.785     0.158  #>  9  1214 0.387     0.508     0.256     0.999     0.417     0.542     0.785  #> 10  1215 0.542     0.0790    0.508     0.256     0.999     0.417     0.542  #> # ℹ 2 more variables: dummy_key <dbl>, .predict <dbl>"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.gaimFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtaining forecasts on a test set from a fitted gaimFit — predict.gaimFit","title":"Obtaining forecasts on a test set from a fitted gaimFit — predict.gaimFit","text":"Gives forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.gaimFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtaining forecasts on a test set from a fitted gaimFit — predict.gaimFit","text":"","code":"# S3 method for class 'gaimFit' predict(   object,   newdata,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.gaimFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtaining forecasts on a test set from a fitted gaimFit — predict.gaimFit","text":"object gaimFit object. newdata set new data forecasts required (.e. test set; tsibble). exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable newdata treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) newdata, break lagged variable sequence even intermediate lags used predictors. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.gaimFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtaining forecasts on a test set from a fitted gaimFit — predict.gaimFit","text":"tsibble forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.gaimFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtaining forecasts on a test set from a fitted gaimFit — predict.gaimFit","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1015 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)    # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1010, ]  # Predictors taken as index variables index.vars <- colnames(sim_data)[3:7]  # Assign group indices for each predictor index.ind = c(rep(1, 3), rep(2, 2))  # Predictors taken as non-linear variables not entering indices s.vars = \"x_lag_005\"  # Model fitting gaimModel <- model_gaim(data = sim_train,                         yvar = \"y\",                         index.vars = index.vars,                         index.ind = index.ind,                         s.vars = s.vars) #> [1] \"model 1\"                          predict(object = gaimModel, newdata = sim_test) #> # A tsibble: 10 x 10 [1] #> # Key:       dummy_key [1] #>    inddd       y x_lag_000 x_lag_001 x_lag_002 x_lag_003 x_lag_004 x_lag_005 #>    <int>   <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl> #>  1  1006  1.13      0.478     0.848     0.853     0.160     0.594     0.274  #>  2  1007  2.72      0.774     0.478     0.848     0.853     0.160     0.594  #>  3  1008  1.54      0.295     0.774     0.478     0.848     0.853     0.160  #>  4  1009  0.0723    0.0656    0.295     0.774     0.478     0.848     0.853  #>  5  1010  0.401     0.441     0.0656    0.295     0.774     0.478     0.848  #>  6  1011  0.524     0.462     0.441     0.0656    0.295     0.774     0.478  #>  7  1012  0.0927    0.341     0.462     0.441     0.0656    0.295     0.774  #>  8  1013  0.310     0.185     0.341     0.462     0.441     0.0656    0.295  #>  9  1014  0.279     0.507     0.185     0.341     0.462     0.441     0.0656 #> 10  1015 -0.0138    0.0192    0.507     0.185     0.341     0.462     0.441  #> # ℹ 2 more variables: dummy_key <dbl>, .predict <dbl>"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.gamFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtaining forecasts on a test set from a fitted gamFit — predict.gamFit","title":"Obtaining forecasts on a test set from a fitted gamFit — predict.gamFit","text":"Gives forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.gamFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtaining forecasts on a test set from a fitted gamFit — predict.gamFit","text":"","code":"# S3 method for class 'gamFit' predict(   object,   newdata,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.gamFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtaining forecasts on a test set from a fitted gamFit — predict.gamFit","text":"object gamFit object. newdata set new data forecasts required (.e. test set; tsibble). exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable newdata treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) newdata, break lagged variable sequence even intermediate lags used predictors. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.gamFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtaining forecasts on a test set from a fitted gamFit — predict.gamFit","text":"tsibble forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.gamFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtaining forecasts on a test set from a fitted gamFit — predict.gamFit","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1015 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)    # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1010, ]  # Predictors taken as non-linear variables s.vars <- colnames(sim_data)[3:6]  # Predictors taken as linear variables linear.vars <- colnames(sim_data)[7:8]  # Model fitting gamModel <- model_gam(data = sim_train,                       yvar = \"y\",                       s.vars = s.vars,                       linear.vars = linear.vars) #> [1] \"model 1\"  predict(object = gamModel, newdata = sim_test) #> # A tsibble: 10 x 10 [1] #> # Key:       dummy_key [1] #>    inddd       y x_lag_000 x_lag_001 x_lag_002 x_lag_003 x_lag_004 x_lag_005 #>    <int>   <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl> #>  1  1006  1.13      0.478     0.848     0.853     0.160     0.594     0.274  #>  2  1007  2.72      0.774     0.478     0.848     0.853     0.160     0.594  #>  3  1008  1.54      0.295     0.774     0.478     0.848     0.853     0.160  #>  4  1009  0.0723    0.0656    0.295     0.774     0.478     0.848     0.853  #>  5  1010  0.401     0.441     0.0656    0.295     0.774     0.478     0.848  #>  6  1011  0.524     0.462     0.441     0.0656    0.295     0.774     0.478  #>  7  1012  0.0927    0.341     0.462     0.441     0.0656    0.295     0.774  #>  8  1013  0.310     0.185     0.341     0.462     0.441     0.0656    0.295  #>  9  1014  0.279     0.507     0.185     0.341     0.462     0.441     0.0656 #> 10  1015 -0.0138    0.0192    0.507     0.185     0.341     0.462     0.441  #> # ℹ 2 more variables: dummy_key <dbl>, .predict <dbl>"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.lmFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtaining forecasts on a test set from a fitted lmFit — predict.lmFit","title":"Obtaining forecasts on a test set from a fitted lmFit — predict.lmFit","text":"Gives forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.lmFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtaining forecasts on a test set from a fitted lmFit — predict.lmFit","text":"","code":"# S3 method for class 'lmFit' predict(object, newdata, recursive = FALSE, recursive_colRange = NULL, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.lmFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtaining forecasts on a test set from a fitted lmFit — predict.lmFit","text":"object lmFit object. newdata set new data forecasts required (.e. test set; tsibble). recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) newdata, break lagged variable sequence even intermediate lags used predictors. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.lmFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtaining forecasts on a test set from a fitted lmFit — predict.lmFit","text":"tsibble forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.lmFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtaining forecasts on a test set from a fitted lmFit — predict.lmFit","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1015 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)    # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1010, ]  # Predictor variables linear.vars <- colnames(sim_data)[3:8]  # Model fitting lmModel <- model_lm(data = sim_train,                     yvar = \"y\",                     linear.vars = linear.vars) #> [1] \"model 1\"                      predict(object = lmModel, newdata = sim_test) #> # A tsibble: 10 x 10 [1] #> # Key:       dummy_key [1] #>    inddd       y x_lag_000 x_lag_001 x_lag_002 x_lag_003 x_lag_004 x_lag_005 #>    <int>   <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl> #>  1  1006  1.13      0.478     0.848     0.853     0.160     0.594     0.274  #>  2  1007  2.72      0.774     0.478     0.848     0.853     0.160     0.594  #>  3  1008  1.54      0.295     0.774     0.478     0.848     0.853     0.160  #>  4  1009  0.0723    0.0656    0.295     0.774     0.478     0.848     0.853  #>  5  1010  0.401     0.441     0.0656    0.295     0.774     0.478     0.848  #>  6  1011  0.524     0.462     0.441     0.0656    0.295     0.774     0.478  #>  7  1012  0.0927    0.341     0.462     0.441     0.0656    0.295     0.774  #>  8  1013  0.310     0.185     0.341     0.462     0.441     0.0656    0.295  #>  9  1014  0.279     0.507     0.185     0.341     0.462     0.441     0.0656 #> 10  1015 -0.0138    0.0192    0.507     0.185     0.341     0.462     0.441  #> # ℹ 2 more variables: dummy_key <dbl>, .predict <dbl>"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.pprFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtaining forecasts on a test set from a fitted pprFit — predict.pprFit","title":"Obtaining forecasts on a test set from a fitted pprFit — predict.pprFit","text":"Gives forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.pprFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtaining forecasts on a test set from a fitted pprFit — predict.pprFit","text":"","code":"# S3 method for class 'pprFit' predict(   object,   newdata,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.pprFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtaining forecasts on a test set from a fitted pprFit — predict.pprFit","text":"object pprFit object. newdata set new data forecasts required (.e. test set; tsibble). exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable newdata treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) newdata, break lagged variable sequence even intermediate lags used predictors. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.pprFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtaining forecasts on a test set from a fitted pprFit — predict.pprFit","text":"tsibble forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.pprFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtaining forecasts on a test set from a fitted pprFit — predict.pprFit","text":"","code":"library(dplyr) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1015 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)    # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1010, ]  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting pprModel <- model_ppr(data = sim_train,                       yvar = \"y\",                       index.vars = index.vars) #> [1] \"model 1\"  predict(object = pprModel, newdata = sim_test) #> # A tsibble: 10 x 10 [1] #> # Key:       dummy_key [1] #>    inddd       y x_lag_000 x_lag_001 x_lag_002 x_lag_003 x_lag_004 x_lag_005 #>    <int>   <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl> #>  1  1006  1.13      0.478     0.848     0.853     0.160     0.594     0.274  #>  2  1007  2.72      0.774     0.478     0.848     0.853     0.160     0.594  #>  3  1008  1.54      0.295     0.774     0.478     0.848     0.853     0.160  #>  4  1009  0.0723    0.0656    0.295     0.774     0.478     0.848     0.853  #>  5  1010  0.401     0.441     0.0656    0.295     0.774     0.478     0.848  #>  6  1011  0.524     0.462     0.441     0.0656    0.295     0.774     0.478  #>  7  1012  0.0927    0.341     0.462     0.441     0.0656    0.295     0.774  #>  8  1013  0.310     0.185     0.341     0.462     0.441     0.0656    0.295  #>  9  1014  0.279     0.507     0.185     0.341     0.462     0.441     0.0656 #> 10  1015 -0.0138    0.0192    0.507     0.185     0.341     0.462     0.441  #> # ℹ 2 more variables: dummy_key <dbl>, .predict <dbl>"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.smimodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtaining forecasts on a test set from a fitted smimodel — predict.smimodel","title":"Obtaining forecasts on a test set from a fitted smimodel — predict.smimodel","text":"Gives forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.smimodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtaining forecasts on a test set from a fitted smimodel — predict.smimodel","text":"","code":"# S3 method for class 'smimodel' predict(   object,   newdata,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.smimodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtaining forecasts on a test set from a fitted smimodel — predict.smimodel","text":"object smimodel object. newdata set new data forecasts required (.e. test set; tsibble). exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable newdata treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) newdata, break lagged variable sequence even intermediate lags used predictors. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.smimodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtaining forecasts on a test set from a fitted smimodel — predict.smimodel","text":"tsibble forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.smimodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtaining forecasts on a test set from a fitted smimodel — predict.smimodel","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr) library(ROI) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1015 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)    # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1010, ]  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting smimodel_ppr <- model_smimodel(data = sim_train,                                yvar = \"y\",                                index.vars = index.vars,                                initialise = \"ppr\")  predict(object = smimodel_ppr, newdata = sim_test) } # }"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.smimodelFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtaining forecasts on a test set from a smimodelFit — predict.smimodelFit","title":"Obtaining forecasts on a test set from a smimodelFit — predict.smimodelFit","text":"Gives forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.smimodelFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtaining forecasts on a test set from a smimodelFit — predict.smimodelFit","text":"","code":"# S3 method for class 'smimodelFit' predict(   object,   newdata,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.smimodelFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtaining forecasts on a test set from a smimodelFit — predict.smimodelFit","text":"object smimodelFit object. newdata set new data forecasts required (.e. test set; tsibble). exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable newdata treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) newdata, break lagged variable sequence even intermediate lags used predictors. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.smimodelFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtaining forecasts on a test set from a smimodelFit — predict.smimodelFit","text":"tibble forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict.smimodelFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtaining forecasts on a test set from a smimodelFit — predict.smimodelFit","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr) library(ROI) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1015 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)    # Training set sim_train <- sim_data[1:1000, ] # Test set sim_test <- sim_data[1001:1010, ]  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting smimodel_ppr <- model_smimodel(data = sim_train,                                yvar = \"y\",                                index.vars = index.vars,                                initialise = \"ppr\")  predict(object = smimodel_ppr$fit[[1]]$best, newdata = sim_test) } # }"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtaining recursive forecasts on a test set from a fitted mgcv::gam — predict_gam","title":"Obtaining recursive forecasts on a test set from a fitted mgcv::gam — predict_gam","text":"Gives recursive forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtaining recursive forecasts on a test set from a fitted mgcv::gam — predict_gam","text":"","code":"predict_gam(   object,   newdata,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtaining recursive forecasts on a test set from a fitted mgcv::gam — predict_gam","text":"object gam object. newdata set new data forecasts required (.e. test set; tsibble). exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable newdata treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers newdata filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) newdata, break lagged variable sequence even intermediate lags used predictors. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/predict_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtaining recursive forecasts on a test set from a fitted mgcv::gam — predict_gam","text":"tibble forecasts test set.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/prep_newdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare a data set for recursive forecasting — prep_newdata","title":"Prepare a data set for recursive forecasting — prep_newdata","text":"Prepare test data recursive forecasting appropriately removing exisiting (actual) values specified range columns (lagged response columns) data set. Handles seasonal data gaps.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/prep_newdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare a data set for recursive forecasting — prep_newdata","text":"","code":"prep_newdata(newdata, recursive_colRange)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/prep_newdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare a data set for recursive forecasting — prep_newdata","text":"newdata Data set prepared. tsibble. recursive_colRange range column numbers (lagged response columns) newdata existing values removed. Make sure columns positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) newdata, break lagged variable sequence even intermediate lags used predictors.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/prep_newdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare a data set for recursive forecasting — prep_newdata","text":"tibble.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.backward.html","id":null,"dir":"Reference","previous_headings":"","what":"Printing a backward object — print.backward","title":"Printing a backward object — print.backward","text":"default print method backward object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.backward.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Printing a backward object — print.backward","text":"","code":"# S3 method for class 'backward' print(x, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.backward.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Printing a backward object — print.backward","text":"x model object class backward produced model_backward() function. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.gaimFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Printing a gaimFit object — print.gaimFit","title":"Printing a gaimFit object — print.gaimFit","text":"default print method gaimFit object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.gaimFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Printing a gaimFit object — print.gaimFit","text":"","code":"# S3 method for class 'gaimFit' print(x, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.gaimFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Printing a gaimFit object — print.gaimFit","text":"x model object class gaimFit produced model_gaim() function. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.pprFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Printing a pprFit object — print.pprFit","title":"Printing a pprFit object — print.pprFit","text":"default print method pprFit object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.pprFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Printing a pprFit object — print.pprFit","text":"","code":"# S3 method for class 'pprFit' print(x, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.pprFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Printing a pprFit object — print.pprFit","text":"x model object class pprFit produced model_ppr() function. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.smimodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Printing a smimodel object — print.smimodel","title":"Printing a smimodel object — print.smimodel","text":"default print method smimodel object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.smimodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Printing a smimodel object — print.smimodel","text":"","code":"# S3 method for class 'smimodel' print(x, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.smimodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Printing a smimodel object — print.smimodel","text":"x object class smimodel. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.smimodelFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Printing a smimodelFit object — print.smimodelFit","title":"Printing a smimodelFit object — print.smimodelFit","text":"default print method smimodelFit object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.smimodelFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Printing a smimodelFit object — print.smimodelFit","text":"","code":"# S3 method for class 'smimodelFit' print(x, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/print.smimodelFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Printing a smimodelFit object — print.smimodelFit","text":"x object class smimodelFit. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/randomBlock.html","id":null,"dir":"Reference","previous_headings":"","what":"Randomly sampling a block — randomBlock","title":"Randomly sampling a block — randomBlock","text":"Samples block specified size given series starting form random point series.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/randomBlock.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Randomly sampling a block — randomBlock","text":"","code":"randomBlock(series, block.size)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/randomBlock.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Randomly sampling a block — randomBlock","text":"series series block sampled. block.size Size block sampled.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/randomBlock.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Randomly sampling a block — randomBlock","text":"numeric vector.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. generics augment, forecast ggplot2 autoplot","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/remove_lags.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove actual values from a data set for recursive forecasting — remove_lags","title":"Remove actual values from a data set for recursive forecasting — remove_lags","text":"Appropriately removes exisiting (actual) values specified column range (lagged response columns) given data set (typicall test set recursive forecasting required).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/remove_lags.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove actual values from a data set for recursive forecasting — remove_lags","text":"","code":"remove_lags(data, recursive_colRange)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/remove_lags.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove actual values from a data set for recursive forecasting — remove_lags","text":"data Data set (tibble) actual lagged values removed. recursive_colRange range column numbers data lagged values removed.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/remove_lags.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove actual values from a data set for recursive forecasting — remove_lags","text":"tibble.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/residBootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate multiple single season block bootstrap series — residBootstrap","title":"Generate multiple single season block bootstrap series — residBootstrap","text":"Generates multiple replications single season block bootstrap series.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/residBootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate multiple single season block bootstrap series — residBootstrap","text":"","code":"residBootstrap(x, season.period = 1, m = 1, num.bootstrap = 1000)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/residBootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate multiple single season block bootstrap series — residBootstrap","text":"x series residuals bootstrap series generated. season.period Length seasonal period. m Multiplier. (Block size = season.period * m) num.bootstrap Number bootstrap series generated.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/residBootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate multiple single season block bootstrap series — residBootstrap","text":"matrix bootstrapped series.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/residuals.smimodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract residuals from a fitted smimodel — residuals.smimodel","title":"Extract residuals from a fitted smimodel — residuals.smimodel","text":"Generates residuals fitted smimodel object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/residuals.smimodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract residuals from a fitted smimodel — residuals.smimodel","text":"","code":"# S3 method for class 'smimodel' residuals(object, ...)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/residuals.smimodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract residuals from a fitted smimodel — residuals.smimodel","text":"object smimodel object. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/residuals.smimodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract residuals from a fitted smimodel — residuals.smimodel","text":"numeric vector residuals.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/residuals.smimodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract residuals from a fitted smimodel — residuals.smimodel","text":"","code":"if (FALSE) { # \\dontrun{ library(dplyr) library(ROI) library(tibble) library(tidyr) library(tsibble)  # Simulate data n = 1005 set.seed(123) sim_data <- tibble(x_lag_000 = runif(n)) |>   mutate(     # Add x_lags     x_lag = lag_matrix(x_lag_000, 5)) |>   unpack(x_lag, names_sep = \"_\") |>   mutate(     # Response variable     y = (0.9*x_lag_000 + 0.6*x_lag_001 + 0.45*x_lag_003)^3 + rnorm(n, sd = 0.1),     # Add an index to the data set     inddd = seq(1, n)) |>   drop_na() |>   select(inddd, y, starts_with(\"x_lag\")) |>   # Make the data set a `tsibble`   as_tsibble(index = inddd)  # Index variables index.vars <- colnames(sim_data)[3:8]  # Model fitting smimodel_ppr <- model_smimodel(data = sim_data,                                yvar = \"y\",                                index.vars = index.vars,                                initialise = \"ppr\")  residuals(smimodel_ppr) } # }"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale data — scaling","title":"Scale data — scaling","text":"Scales columns data corresponding index.vars.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale data — scaling","text":"","code":"scaling(data, index.vars)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale data — scaling","text":"data Training data set models trained. tibble. index.vars character vector names predictor variables indices estimated.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale data — scaling","text":"list containing following components: scaled_data scaled data set class tibble. scaled_info named numeric vector standard deviations index.vars used scale corresponding columns data.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/seasonBootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Single season block bootstrap — seasonBootstrap","title":"Single season block bootstrap — seasonBootstrap","text":"Generates single replication single season block bootstrap series.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/seasonBootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Single season block bootstrap — seasonBootstrap","text":"","code":"seasonBootstrap(x, season.period = 1, m = 1)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/seasonBootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Single season block bootstrap — seasonBootstrap","text":"x series residuals bootstrap series generated. season.period Length seasonal period. m Multiplier. (Block size = season.period * m)","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/seasonBootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Single season block bootstrap — seasonBootstrap","text":"numeric vector.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/smimodel-package.html","id":null,"dir":"Reference","previous_headings":"","what":"smimodel: Sparse Multiple Index Models for Nonparametric Forecasting — smimodel-package","title":"smimodel: Sparse Multiple Index Models for Nonparametric Forecasting — smimodel-package","text":"Implements general algorithm estimating Sparse Multiple Index (SMI) models nonparametric forecasting prediction. Includes functions fitting nonparametric additive models backward elimination, group-wise additive index models, projection pursuit regression models benchmark comparison methods. Provides tools generating prediction intervals quantify uncertainty point forecasts produced SMI model benchmark models, using classical block bootstrap method new method called conformal bootstrap, integrates block bootstrap split conformal prediction.","code":""},{"path":[]},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/smimodel-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"smimodel: Sparse Multiple Index Models for Nonparametric Forecasting — smimodel-package","text":"Maintainer: Nuwani Palihawadana nuwanipalihawadana@gmail.com (ORCID) [copyright holder] contributors: Xiaoqian Wang Xiaoqian.Wang@amss.ac.cn (ORCID) [contributor]","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/smimodel.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"SMI model estimation — smimodel.fit","title":"SMI model estimation — smimodel.fit","text":"Fits single nonparametric multiple index model data. helper function designed called user-facing wrapper functions, model_smimodel greedy_smimodel.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/smimodel.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SMI model estimation — smimodel.fit","text":"","code":"smimodel.fit(   data,   yvar,   neighbour = 0,   family = gaussian(),   index.vars,   initialise = c(\"ppr\", \"additive\", \"linear\", \"multiple\", \"userInput\"),   num_ind = 5,   num_models = 5,   seed = 123,   index.ind = NULL,   index.coefs = NULL,   s.vars = NULL,   linear.vars = NULL,   lambda0 = 1,   lambda2 = 1,   M = 10,   max.iter = 50,   tol = 0.001,   tolCoefs = 0.001,   TimeLimit = Inf,   MIPGap = 1e-04,   NonConvex = -1,   verbose = FALSE )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/smimodel.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SMI model estimation — smimodel.fit","text":"data Training data set models trained. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). yvar Name response variable character string. neighbour neighbour argument passed outer function. family description error distribution link function used model (see glm family). index.vars character vector names predictor variables indices estimated. initialise model structure estimation process initialised. default \"ppr\", initial model derived projection pursuit regression. options \"additive\" - nonparametric additive model, \"linear\" - linear regression model (.e. special case single-index model, initial values index coefficients obtained linear regression), \"multiple\" - multiple models fitted starting different initial models (number indices = num_ind; num_models random instances model (.e. predictor assignment indices initial index coefficients generated randomly) considered), final optimal model lowest loss returned, \"userInput\" - user specifies initial model structure (.e. number indices placement index variables among indices) initial index coefficients index.ind index.coefs arguments respectively. num_ind initialise = \"ppr\" \"multiple\": integer specifies number indices used model(s). default num_ind = 5. num_models initialise = \"multiple\": integer specifies number starting models checked. default num_models = 5. seed initialise = \"multiple\": seed set generating random starting points. index.ind initialise = \"userInput\": integer vector assigns group index predictor index.vars. index.coefs initialise = \"userInput\": numeric vector index coefficients. s.vars character vector names predictor variables splines fitted individually (rather considering part index). linear.vars character vector names predictor variables included linearly model. lambda0 Penalty parameter L0 penalty. lambda2 Penalty parameter L2 penalty. M Big-M value used MIP. max.iter Maximum number MIP iterations performed update index coefficients given model. tol Tolerance objective function value (loss) MIP. tolCoefs Tolerance coefficients. TimeLimit limit total time (seconds) expended single MIP iteration. MIPGap Relative MIP optimality gap. NonConvex strategy handling non-convex quadratic objectives non-convex quadratic constraints Gurobi solver. verbose option print detailed solver output.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/smimodel.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SMI model estimation — smimodel.fit","text":"list two elements: initial list information model initialisation. (descriptions list elements see make_smimodelFit). best list information final optimised model. (descriptions list elements see make_smimodelFit).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/split_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Splitting predictors into multiple indices — split_index","title":"Splitting predictors into multiple indices — split_index","text":"Splits given number predictors given number indices.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/split_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Splitting predictors into multiple indices — split_index","text":"","code":"split_index(num_pred, num_ind)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/split_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Splitting predictors into multiple indices — split_index","text":"num_pred Number predictors. num_ind Number indices.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/split_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Splitting predictors into multiple indices — split_index","text":"list containing following components: index integer vector assigns group indices predictor. index_positions list length = num_ind indicates predictors belong index.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/truncate_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Truncating predictors to be in the in-sample range — truncate_vars","title":"Truncating predictors to be in the in-sample range — truncate_vars","text":"Truncates predictors -sample range avoid spline extrapolation.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/truncate_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Truncating predictors to be in the in-sample range — truncate_vars","text":"","code":"truncate_vars(range.object, data, cols.trunc)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/truncate_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Truncating predictors to be in the in-sample range — truncate_vars","text":"range.object matrix containing range predictor variable. matrix two rows min max, columns correspond variables. data --sample data set variables truncated. cols.trunc Column names variables truncated.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/tune_smimodel.html","id":null,"dir":"Reference","previous_headings":"","what":"SMI model with a given penalty parameter combination — tune_smimodel","title":"SMI model with a given penalty parameter combination — tune_smimodel","text":"Fits nonparametric multiple index model data given combination penalty parameters (lambda0, lambda2), returns validation set mean squared error (MSE). (Used within greedy.fit; users expected use function directly.)","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/tune_smimodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SMI model with a given penalty parameter combination — tune_smimodel","text":"","code":"tune_smimodel(   data,   val.data,   yvar,   neighbour = 0,   family = gaussian(),   index.vars,   initialise = c(\"ppr\", \"additive\", \"linear\", \"multiple\", \"userInput\"),   num_ind = 5,   num_models = 5,   seed = 123,   index.ind = NULL,   index.coefs = NULL,   s.vars = NULL,   linear.vars = NULL,   lambda.comb = c(1, 1),   M = 10,   max.iter = 50,   tol = 0.001,   tolCoefs = 0.001,   TimeLimit = Inf,   MIPGap = 1e-04,   NonConvex = -1,   verbose = FALSE,   exclude.trunc = NULL,   recursive = FALSE,   recursive_colRange = NULL )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/tune_smimodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SMI model with a given penalty parameter combination — tune_smimodel","text":"data Training data set models trained. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). val.data Validation data set. (data set penalty parameter selection performed.) Must data set class tsibble. (penalty parameter selection completed, best model re-fitted combined data set data +   val.data.) yvar Name response variable character string. neighbour neighbour argument passed outer function. family description error distribution link function used model (see glm family). index.vars character vector names predictor variables indices estimated. initialise model structure estimation process initialised. default \"ppr\", initial model derived projection pursuit regression. options \"additive\" - nonparametric additive model, \"linear\" - linear regression model (.e. special case single-index model, initial values index coefficients obtained linear regression), \"multiple\" - multiple models fitted starting different initial models (number indices = num_ind; num_models random instances model (.e. predictor assignment indices initial index coefficients generated randomly) considered), final optimal model lowest loss returned, \"userInput\" - user specifies initial model structure (.e. number indices placement index variables among indices) initial index coefficients index.ind index.coefs arguments respectively. num_ind initialise = \"ppr\" \"multiple\": integer specifies number indices used model(s). default num_ind = 5. num_models initialise = \"multiple\": integer specifies number starting models checked. default num_models = 5. seed initialise = \"multiple\": seed set generating random starting points. index.ind initialise = \"userInput\": integer vector assigns group index predictor index.vars. index.coefs initialise = \"userInput\": numeric vector index coefficients. s.vars character vector names predictor variables splines fitted individually (rather considering part index). linear.vars character vector names predictor variables included linearly model. lambda.comb numeric vector (length two) indicating values two penalty parameters lambda0 lambda2. M Big-M value used MIP. max.iter Maximum number MIP iterations performed update index coefficients given model. tol Tolerance objective function value (loss) MIP. tolCoefs Tolerance coefficients. TimeLimit limit total time (seconds) expended single MIP iteration. MIPGap Relative MIP optimality gap. NonConvex strategy handling non-convex quadratic objectives non-convex quadratic constraints Gurobi solver. verbose option print detailed solver output. exclude.trunc names predictor variables truncated stable predictions character string. (Since nonlinear functions estimated using splines, extrapolation desirable. Hence, predictor variable val.data treated non-linearly estimated model, truncated -sample range obtaining predictions. variables listed excluded truncation.) recursive Whether obtain recursive forecasts (default - FALSE). recursive_colRange recursive = TRUE, range column numbers val.data filled forecasts. Recursive/autoregressive forecasting required lags response variable used predictor variables model. Make sure lagged variables positioned together increasing lag order (.e. lag_1, lag_2, ..., lag_m, lag_m = maximum lag used) val.data, break lagged variable sequence even intermediate lags used predictors.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/tune_smimodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SMI model with a given penalty parameter combination — tune_smimodel","text":"numeric.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/unscaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Unscale a fitted smimodel — unscaling","title":"Unscale a fitted smimodel — unscaling","text":"Transforms back index coefficients suit original-scale index variables scaled estimating smimodel (happens initialise = \"ppr\" model_smimodel greedy_smimodel). Users expected directly use function; usually called within smimodel.fit.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/unscaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unscale a fitted smimodel — unscaling","text":"","code":"unscaling(object, scaledInfo)"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/unscaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unscale a fitted smimodel — unscaling","text":"object smimodel object. scaledInfo list returned call function scaling.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/unscaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unscale a fitted smimodel — unscaling","text":"smimodel object.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/update_alpha.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating index coefficients using MIP — update_alpha","title":"Updating index coefficients using MIP — update_alpha","text":"Updates index coefficients solving mixed integer program.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/update_alpha.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating index coefficients using MIP — update_alpha","text":"","code":"update_alpha(   Y,   X,   num_pred,   num_ind,   index.ind,   dgz,   alpha_old,   lambda0 = 1,   lambda2 = 1,   M = 10,   TimeLimit = Inf,   MIPGap = 1e-04,   NonConvex = -1,   verbose = FALSE )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/update_alpha.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating index coefficients using MIP — update_alpha","text":"Y Column matrix response. X Matrix predictors (size adjusted number indices). num_pred Number predictors. num_ind Number indices. index.ind integer vector assigns group index predictor. dgz tibble derivatives estimated smooths previous iteration. alpha_old Vector index coefficients previous iteration. lambda0 Penalty parameter L0 penalty. lambda2 Penalty parameter L2 penalty. M Big-M value used MIP. TimeLimit limit total time (seconds) expended single MIP iteration. MIPGap Relative MIP optimality gap. NonConvex strategy handling non-convex quadratic objectives non-convex quadratic constraints Gurobi solver. verbose option print detailed solver output.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/update_alpha.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating index coefficients using MIP — update_alpha","text":"vector normalised index coefficients.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/update_smimodelFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating a smimodelFit — update_smimodelFit","title":"Updating a smimodelFit — update_smimodelFit","text":"Optimises updates given smimodelFit.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/update_smimodelFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating a smimodelFit — update_smimodelFit","text":"","code":"update_smimodelFit(   object,   data,   lambda0 = 1,   lambda2 = 1,   M = 10,   max.iter = 50,   tol = 0.001,   tolCoefs = 0.001,   TimeLimit = Inf,   MIPGap = 1e-04,   NonConvex = -1,   verbose = FALSE,   ... )"},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/update_smimodelFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating a smimodelFit — update_smimodelFit","text":"object smimodelFit object. data Training data set models trained. Must data set class tsibble.(Make sure additional date time related variables except index tsibble). lambda0 Penalty parameter L0 penalty. lambda2 Penalty parameter L2 penalty. M Big-M value used MIP. max.iter Maximum number MIP iterations performed update index coefficients given model. tol Tolerance objective function value (loss) MIP. tolCoefs Tolerance coefficients. TimeLimit limit total time (seconds) expended single MIP iteration. MIPGap Relative MIP optimality gap. NonConvex strategy handling non-convex quadratic objectives non-convex quadratic constraints Gurobi solver. verbose option print detailed solver output. ... arguments currently used.","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/reference/update_smimodelFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating a smimodelFit — update_smimodelFit","text":"list optimised model information. descriptions list elements see make_smimodelFit).","code":""},{"path":"https://nuwani-palihawadana.github.io/smimodel/news/index.html","id":"smimodel-001","dir":"Changelog","previous_headings":"","what":"smimodel 0.0.1","title":"smimodel 0.0.1","text":"Initial CRAN submission.","code":""}]
