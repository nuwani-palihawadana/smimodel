---
title: "Introduction to smimodel"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to smimodel}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



## What is smimodel?

The *smimodel* package provides functions to estimate **Sparse Multiple Index (SMI) Models** for nonparametric forecasting or prediction. To support time series forecasting, the package functions are mainly build upon tidy temporal data in the `tsibble` format. However, the SMI model formulation is very general and does not exclusively depend on any temporal features. Hence, the model can be used more widely -- even with non-temporal cross-sectional data. (In such case, a numeric `index` (instead of a date or time related variable) can be used when constructing the `tsibble`.)

The SMI Modelling algorithm (i.e. the estimation algorithm of SMI model) that we implement here, simultaneously performs automatic predictor selection ("sparse") and predictor grouping, which is especially useful in obtaining a parsimonious model in high-dimensional contexts. For detailed information regarding the SMI model and the estimation algorithm refer the related working paper at https://www.monash.edu/business/ebs/research/publications/ebs/2024/wp16-2024.pdf.

## How to use smimodel?

Here we present a simple example to illustrate *smimodel* functionalities. We use randomly simualted data, which we treat as time series data for the purpose of this illustration. 

(Note: Since the SMI model estimation algorithm works with very limited amount of prior information, and handles automatic predictor selection and predictor grouping, the computational time for model estimation increases as the number of predictors and the number of indices increase. Therefore, we use a small simulated data set here as the example to reduce computational cost.)

### Data simulation

Suppose we are interested in forecasting a response variable $y$, which is an additive function of two nonlinear components involving five predictor variables $x\_000, x\_001, x\_002, x\_003$ and $x\_005$ plus a normally distributed white noise component. Here, the variables $x\_001, x\_002, x\_003$ and $x\_005$ correspond to the first, second, third and fifth lags of $x\_000$ respectively. 


``` r
## Load required packages 
library(smimodel)
library(dplyr)
library(ROI)
library(tibble)
library(tidyr)
library(tsibble)
```


``` r
## Simulate data

# Length of the time series
n = 1405 

# Set a seed for reproduciblity
set.seed(123)

# Generate data
sim_data <- tibble(x_000 = runif(n)) |> 
  mutate(
    # Add x_lags
    x = lag_matrix(x_000, 5)) |> 
  unpack(x, names_sep = "_") |> 
  mutate(
    # Response variable
    y = (0.9*x_000 + 0.6*x_001 + 0.45*x_003)^3 + 
      (0.35*x_002 + 0.7*x_005)^2 + rnorm(n, sd = 0.1),
    # Add an index to the data set
    inddd = seq(1, n)) |> 
  drop_na() |> 
  select(inddd, y, starts_with("x_")) |> 
  # Make the data set a `tsibble`
  as_tsibble(index = inddd)
```

Note that here we create an additional `numeric` variable `inddd` to serve as the `index` of the data set, when we convert the data set into an object of class `tsibble`. 

Next, we split the data into training and test sets so that the models can be estimated using the training data set, and the fitted models can be evaluated on the predictions obtained for the test set, which is not used for model estimation. 


``` r
## Data Split

# Training set
sim_train <- sim_data[1:1200, ]

# Test set
sim_test <- sim_data[1201:1400, ]

# Here, we sequentially split the data as we assume time series data. 
```

### SMI model estimation

We first train SMI models on the training set using three different initialisation options "ppr", "additive" and "linear" for comparison purposes. Please refer to package documentation/working paper for more information regarding available initialisation options.

(Note: The choice of the initialisation largely depends on the data and application. Thus, users are encouraged to follow a trial-and-error procedure to determine the most suitable initial model for a given application.)

Here, we assume that we do not have any prior knowledge about the construction of the response variable $y$. Hence, we input $x\_000$ and its first five lags as our predictor variables into the estimation algorithm, as predictors which are entering indices. 


``` r
## Index variables
index.vars <- colnames(sim_data)[3:8]
```

#### SMI model with "ppr" initialisation:

``` r
## SMI model with "PPR" initialisation
smimodel_ppr <- model_smimodel(data = sim_train,
                               yvar = "y",
                               index.vars = index.vars,
                               initialise = "ppr")
#> [1] "model 1"
#> [1] "Tolerance for loss reached!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Final model fitted!"
```


``` r
# Fitted optimal SMI model
smimodel_ppr$fit[[1]]$best
#> SMI Model Fit:
#> Index coefficients:
#> 6 x 2 sparse Matrix of class "dgCMatrix"
#>          index1   index2
#> x_000 1.6277830 .       
#> x_001 1.0729663 .       
#> x_002 .         1.213462
#> x_003 0.8107518 .       
#> x_004 .         .       
#> x_005 .         2.296776
#> 
#> Response variable:
#> [1] "y"
#> 
#> Index variables:
#> [1] "x_000" "x_001" "x_002" "x_003" "x_004" "x_005"
#> 
#> Spline variables (non-index):
#> NULL
#> 
#> Linear variables:
#> NULL
#> 
#> GAM Fit:
#> Family: gaussian 
#> Link function: identity 
#> 
#> Formula:
#> y ~ s(index1, bs = "cr") + s(index2, bs = "cr")
#> 
#> Estimated degrees of freedom:
#> 8.5 6.1  total = 15.6 
#> 
#> REML score: -1028.843
```


``` r
# Estimated index structure
smimodel_ppr$fit[[1]]$best$alpha
#> 6 x 2 sparse Matrix of class "dgCMatrix"
#>          index1   index2
#> x_000 1.6277830 .       
#> x_001 1.0729663 .       
#> x_002 .         1.213462
#> x_003 0.8107518 .       
#> x_004 .         .       
#> x_005 .         2.296776
```

#### SMI model with "additive" initialisation:

``` r
## SMI model with "Additive" initialisation
smimodel_additive <- model_smimodel(data = sim_train,
                                    yvar = "y",
                                    index.vars = index.vars,
                                    initialise = "additive")
#> [1] "model 1"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Final model fitted!"
```


``` r
# Fitted optimal SMI model
smimodel_additive$fit[[1]]$best
#> SMI Model Fit:
#> Index coefficients:
#> 6 x 2 sparse Matrix of class "dgCMatrix"
#>          index1   index2
#> x_000 0.4634888 .       
#> x_001 0.3055250 .       
#> x_002 .         0.345865
#> x_003 0.2309862 .       
#> x_004 .         .       
#> x_005 .         0.654135
#> 
#> Response variable:
#> [1] "y"
#> 
#> Index variables:
#> [1] "x_000" "x_001" "x_002" "x_003" "x_004" "x_005"
#> 
#> Spline variables (non-index):
#> NULL
#> 
#> Linear variables:
#> NULL
#> 
#> GAM Fit:
#> Family: gaussian 
#> Link function: identity 
#> 
#> Formula:
#> y ~ s(index1, bs = "cr") + s(index2, bs = "cr")
#> 
#> Estimated degrees of freedom:
#> 8.5 6.1  total = 15.6 
#> 
#> REML score: -1028.838
```


``` r
# Estimated index structure
smimodel_additive$fit[[1]]$best$alpha
#> 6 x 2 sparse Matrix of class "dgCMatrix"
#>          index1   index2
#> x_000 0.4634888 .       
#> x_001 0.3055250 .       
#> x_002 .         0.345865
#> x_003 0.2309862 .       
#> x_004 .         .       
#> x_005 .         0.654135
```

#### SMI model with "linear" initialisation:

``` r
## SMI model with "Linear" initialisation
smimodel_linear <- model_smimodel(data = sim_train,
                                  yvar = "y",
                                  index.vars = index.vars,
                                  initialise = "linear")
#> [1] "model 1"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Final model fitted!"
```


``` r
# Fitted optimal SMI model
smimodel_linear$fit[[1]]$best
#> SMI Model Fit:
#> Index coefficients:
#> 6 x 2 sparse Matrix of class "dgCMatrix"
#>          index1    index2
#> x_000 0.4636130 .        
#> x_001 0.3055494 .        
#> x_002 .         0.3467785
#> x_003 0.2308376 .        
#> x_004 .         .        
#> x_005 .         0.6532215
#> 
#> Response variable:
#> [1] "y"
#> 
#> Index variables:
#> [1] "x_000" "x_001" "x_002" "x_003" "x_004" "x_005"
#> 
#> Spline variables (non-index):
#> NULL
#> 
#> Linear variables:
#> NULL
#> 
#> GAM Fit:
#> Family: gaussian 
#> Link function: identity 
#> 
#> Formula:
#> y ~ s(index1, bs = "cr") + s(index2, bs = "cr")
#> 
#> Estimated degrees of freedom:
#> 8.50 6.12  total = 15.62 
#> 
#> REML score: -1028.798
```


``` r
# Estimated index structure
smimodel_linear$fit[[1]]$best$alpha
#> 6 x 2 sparse Matrix of class "dgCMatrix"
#>          index1    index2
#> x_000 0.4636130 .        
#> x_001 0.3055494 .        
#> x_002 .         0.3467785
#> x_003 0.2308376 .        
#> x_004 .         .        
#> x_005 .         0.6532215
```


In this case, all three SMI models fitted (with "ppr", "additive" and "linear" initialisation options) have correctly identified the index structure of the response $y$ by estimating two linear combinations (i.e. indices), while dropping out the irrelevant predictor $x\_004$. 

(Note: The final estimated model may change depending on the initialisation option chosen. Hence, the users are encouraged to experiment with different available initialisation options when choosing the best fit for the data/application of interest. In a real-world problem (where the true model is unknown), it will be useful to fit SMI models with different initialisation options, and see which option gives the best forecasting/prediction accuracy.)

### Visualisation of estimated smooths

Once you fit a SMI model, the partial effects of the estimated smooths corresponding to the estimated indices can be plotted using the `autoplot` method as below. 


``` r
## Plot estimated smooths of the SMI model with "ppr" initialisation
autoplot(object = smimodel_ppr)
```

![plot of chunk autoplot](figure/autoplot-1.png)

### Residuals and fitted values

We can use the `augment` method to obtain the residuals and the fitted values from an estimated SMI model.


``` r
## Obtain residuals and fitted values
augment(x = smimodel_ppr)
#> # A tibble: 1,200 × 3
#>    Index   .resid .fitted
#>    <int>    <dbl>   <dbl>
#>  1     6  0.0560    0.758
#>  2     7 -0.0398    1.50 
#>  3     8 -0.0549    3.78 
#>  4     9  0.0500    1.78 
#>  5    10  0.155     1.88 
#>  6    11 -0.145     3.70 
#>  7    12  0.200     2.16 
#>  8    13 -0.00581   2.20 
#>  9    14 -0.0587    2.78 
#> 10    15  0.0687    0.588
#> # ℹ 1,190 more rows
```

### Forecasts on a test set

Based on an estimated SMI model, we obtain forecasts/predictions on a test set as below, using the `predict` method.


``` r
## Obtain forecasts on the test set
preds = predict(object = smimodel_ppr, newdata = sim_test)
preds$.predict
#>          1          2          3          4          5          6          7          8 
#> 3.45843482 1.52233929 0.52915671 2.23979539 1.12095152 1.37701048 3.45916664 1.29311926 
#>          9         10         11         12         13         14         15         16 
#> 1.30501441 0.76679807 0.94005154 1.69171847 1.19072414 1.31337854 1.62219972 2.32412054 
#>         17         18         19         20         21         22         23         24 
#> 0.83485639 1.04503698 1.18641786 4.77792576 0.61146893 1.14608392 0.79743662 1.40762829 
#>         25         26         27         28         29         30         31         32 
#> 2.33510632 0.17597884 0.55499981 0.36522200 0.86654016 0.58190432 0.07687419 0.12706185 
#>         33         34         35         36         37         38         39         40 
#> 0.59343493 2.34185400 0.88253877 0.31336997 0.47271658 0.98664796 1.08475055 1.63218384 
#>         41         42         43         44         45         46         47         48 
#> 1.08462208 0.94685717 0.69773155 0.29353883 1.42673101 1.80559706 1.56668680 1.60935120 
#>         49         50         51         52         53         54         55         56 
#> 0.47009455 0.52983748 1.75310041 0.35657771 0.52346543 2.84389939 1.52548116 1.21179344 
#>         57         58         59         60         61         62         63         64 
#> 1.57460678 0.35170993 0.81595949 1.16945351 0.14737637 0.76259052 3.59274308 0.41202691 
#>         65         66         67         68         69         70         71         72 
#> 2.45045046 1.07377542 0.95611899 2.54999411 0.60652246 3.72765379 1.90551702 2.62672272 
#>         73         74         75         76         77         78         79         80 
#> 2.97464279 1.17286068 1.32248353 0.58831081 1.53233149 2.14607215 1.74226840 2.66106411 
#>         81         82         83         84         85         86         87         88 
#> 0.79446176 2.20873718 1.95711933 1.04782140 1.37583209 2.27205189 1.86749216 0.84887843 
#>         89         90         91         92         93         94         95         96 
#> 2.17380289 1.42472135 0.92674929 2.26138084 2.21902797 3.09125236 2.79493313 0.60640910 
#>         97         98         99        100        101        102        103        104 
#> 1.10386530 1.38544895 1.84807628 2.95947510 1.75696400 0.83750488 0.44672968 1.24063710 
#>        105        106        107        108        109        110        111        112 
#> 0.44698763 0.43814184 0.43480837 1.11387344 0.90802148 0.98412301 0.77399901 0.92781919 
#>        113        114        115        116        117        118        119        120 
#> 1.44309503 0.53601097 0.70986280 0.71780586 1.41745632 1.35757618 2.13593015 2.08429787 
#>        121        122        123        124        125        126        127        128 
#> 2.88104888 0.93104399 2.19651802 0.26130171 1.22262725 1.28590866 0.54812550 1.30396156 
#>        129        130        131        132        133        134        135        136 
#> 1.46480333 1.18319405 0.66373798 1.22840273 2.41410935 2.60613213 2.59292461 0.97764028 
#>        137        138        139        140        141        142        143        144 
#> 1.39710638 1.03590256 0.73885115 1.11010945 2.98224561 1.16424945 1.56661578 2.29979223 
#>        145        146        147        148        149        150        151        152 
#> 1.45017582 1.01202295 0.19616637 0.24760981 0.17676178 0.24514812 0.11934916 0.06336549 
#>        153        154        155        156        157        158        159        160 
#> 0.78679674 0.77522978 0.44446630 2.11473265 0.36401620 1.84107675 1.72220377 0.56277107 
#>        161        162        163        164        165        166        167        168 
#> 0.86527742 0.15397755 0.86058688 0.36201708 0.16952403 0.38383432 0.08906202 0.44081266 
#>        169        170        171        172        173        174        175        176 
#> 0.88282070 1.29237794 2.58721676 1.48405203 3.04060340 1.20293468 1.04606752 2.14209043 
#>        177        178        179        180        181        182        183        184 
#> 0.44201454 2.79361783 0.52732444 1.55414248 1.42598659 0.36663459 2.72500268 0.29617963 
#>        185        186        187        188        189        190        191        192 
#> 0.87044077 2.92102132 1.94128710 1.64401566 1.23797710 0.96011158 2.37027743 2.37107628 
#>        193        194        195        196        197        198        199        200 
#> 1.44414361 0.58086686 0.37871181 0.50380451 0.34436357 0.18857385 0.20219476 0.26610323
```

Once we obtain forecasts/predictions, we can evaluate the forecasting/predictive performance of the estimated SMI model by calculating forecast/prediction error measurements as desired.


``` r
## Calculate test set MSE and MAE
MSE_SMI_ppr = MSE(residuals = (preds$y - preds$.predict))
MSE_SMI_ppr
#> [1] 0.01267114
MAE_SMI_ppr = MAE(residuals = (preds$y - preds$.predict))
MAE_SMI_ppr
#> [1] 0.08956175
```

### Tuning for penalty parameters

The estimation of a SMI model involves solving an optimaisation problem, where the sum of squared errors of the model plus two penalty terms (an L0 penalty and an L2 (ridge) penalty) is minimised subject to a set of constraints (please refer the working paper for details). Thus, two penalty parameters $\lambda_{0}$ and $\lambda_{2}$ corresponding to the L0 and L2 penalties respectively should be chosen when estimating a SMI model. 

In the previous example, all the SMI models were fitted using the default penalty parameter values provided in the function: $\lambda_{0} = 1$ and $\lambda_{2} = 1$. To fit a SMI model with simultaneous parameter tuning, we can use the function `greedy_smimodel()`, which performs a greedy search over a given grid of penalty parameter combinations ($\lambda_{0}$, $\lambda_{2}$), and fits the SMI model using the best (lowest validation set MSE) penalty parameter combination. In this case, we need to provide a validation set, which is separate from the training data set. 

Therefore, let's split our original training set in the above example into two parts again to obtain a validation set. 


``` r
# New training set
sim_train_new <- sim_data[1:1000, ]

# Validation set
sim_val_new <- sim_data[1001:1200, ]
```

Next, we can estimate the SMI model with simultaneous penalty parameter tuning as follows. Here, we use the initialisation option "ppr" just to demonstrate the functionality. 


``` r
## Estimating SMI model with penalty parameter tuning
smimodel_ppr_tune <- greedy_smimodel(data = sim_train_new, 
                                     val.data = sim_val_new,
                                     yvar = "y",
                                     index.vars = index.vars,
                                     initialise = "ppr")
#> [1] "model 1"
#> [1] "model 1"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Final model fitted!"
#> [1] "Potential starting points completed."
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Initial search around potential starting point 1 completed."
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Initial search around potential starting point 2 completed."
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Initial search around potential starting point 3 completed."
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Maximum iterations reached!"
#> [1] "Final model fitted!"
#> [1] "Initial search around potential starting point 4 completed."
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Final model fitted!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Final model fitted!"
#> [1] "Initial search around potential starting point 5 completed."
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Initial search around potential starting point 6 completed."
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Initial search around potential starting point 7 completed."
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Final model fitted!"
#> [1] "Initial search around potential starting point 8 completed."
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Tolerance for loss reached!"
#> [1] "Final model fitted!"
#> [1] "Tolerance for loss reached!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Final model fitted!"
#> [1] "Initial search around potential starting point 9 completed."
#> [1] "Starting point for the greedy search selected."
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Loss increased for 3 consecutive iterations!"
#> [1] "Final model fitted!"
#> [1] "Final SMI model is fitted."
```


``` r
# Fitted optimal SMI model
smimodel_ppr_tune$fit[[1]]$best
#> SMI Model Fit:
#> Index coefficients:
#> 6 x 2 sparse Matrix of class "dgCMatrix"
#>          index1   index2
#> x_000 1.6275097 .       
#> x_001 1.0728695 .       
#> x_002 .         1.214242
#> x_003 0.8111214 .       
#> x_004 .         .       
#> x_005 .         2.295995
#> 
#> Response variable:
#> [1] "y"
#> 
#> Index variables:
#> [1] "x_000" "x_001" "x_002" "x_003" "x_004" "x_005"
#> 
#> Spline variables (non-index):
#> NULL
#> 
#> Linear variables:
#> NULL
#> 
#> GAM Fit:
#> Family: gaussian 
#> Link function: identity 
#> 
#> Formula:
#> y ~ s(index1, bs = "cr") + s(index2, bs = "cr")
#> 
#> Estimated degrees of freedom:
#> 8.5 6.1  total = 15.6 
#> 
#> REML score: -1028.836
```


``` r
## Selected penalty parameter combination
smimodel_ppr_tune$fit[[1]]$best_lambdas
#> [1] 1.180046 1.000000
```

Here the selected penalty parameter combination is $(\lambda_{0}, \lambda_{2}) = (1.180046, 1.000000)$.
